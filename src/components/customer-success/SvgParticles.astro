---
interface Props {
  class?: string
}

const { class: className = '' } = Astro.props
---

<div id="svg-particles-container" class:list={["w-full h-full", className]}></div>

<script>
  import * as THREE from 'three';

  // SVG path definitions - simple geometric shapes
  const svgShapes = {
    // Vercel triangle
    vercel: [
      { type: 'line', points: [[37.5, 0], [75, 65]] },
      { type: 'line', points: [[75, 65], [0, 65]] },
      { type: 'line', points: [[0, 65], [37.5, 0]] }
    ],
    // Framer F shape
    framer: [
      { type: 'line', points: [[0, 0], [48, 0]] },
      { type: 'line', points: [[48, 0], [48, 24]] },
      { type: 'line', points: [[48, 24], [24, 24]] },
      { type: 'line', points: [[24, 24], [0, 0]] },
      { type: 'line', points: [[0, 24], [24, 24]] },
      { type: 'line', points: [[24, 24], [48, 48]] },
      { type: 'line', points: [[48, 48], [24, 48]] },
      { type: 'line', points: [[24, 48], [24, 72]] },
      { type: 'line', points: [[24, 72], [0, 48]] },
      { type: 'line', points: [[0, 48], [0, 24]] }
    ],
    // Cube / Box wireframe
    cube: [
      // Front face
      { type: 'line', points: [[20, 30], [80, 30]] },
      { type: 'line', points: [[80, 30], [80, 90]] },
      { type: 'line', points: [[80, 90], [20, 90]] },
      { type: 'line', points: [[20, 90], [20, 30]] },
      // Back face
      { type: 'line', points: [[35, 10], [95, 10]] },
      { type: 'line', points: [[95, 10], [95, 70]] },
      { type: 'line', points: [[95, 70], [35, 70]] },
      { type: 'line', points: [[35, 70], [35, 10]] },
      // Connecting edges
      { type: 'line', points: [[20, 30], [35, 10]] },
      { type: 'line', points: [[80, 30], [95, 10]] },
      { type: 'line', points: [[80, 90], [95, 70]] },
      { type: 'line', points: [[20, 90], [35, 70]] }
    ],
    // Star shape
    star: [
      { type: 'line', points: [[50, 0], [61, 35]] },
      { type: 'line', points: [[61, 35], [98, 35]] },
      { type: 'line', points: [[98, 35], [68, 57]] },
      { type: 'line', points: [[68, 57], [79, 91]] },
      { type: 'line', points: [[79, 91], [50, 70]] },
      { type: 'line', points: [[50, 70], [21, 91]] },
      { type: 'line', points: [[21, 91], [32, 57]] },
      { type: 'line', points: [[32, 57], [2, 35]] },
      { type: 'line', points: [[2, 35], [39, 35]] },
      { type: 'line', points: [[39, 35], [50, 0]] }
    ],
    // Abstract cross/plus
    cross: [
      { type: 'line', points: [[50, 0], [50, 100]] },
      { type: 'line', points: [[0, 50], [100, 50]] },
      { type: 'line', points: [[15, 15], [85, 85]] },
      { type: 'line', points: [[85, 15], [15, 85]] }
    ]
  };

  // Sample points along a line
  function sampleLine(p1: number[], p2: number[], numSamples: number): number[][] {
    const points: number[][] = [];
    for (let i = 0; i <= numSamples; i++) {
      const t = i / numSamples;
      points.push([
        p1[0] + (p2[0] - p1[0]) * t,
        p1[1] + (p2[1] - p1[1]) * t
      ]);
    }
    return points;
  }

  // Generate points from shape definition
  function generateShapePoints(shape: typeof svgShapes.vercel, totalPoints: number, scale: number, centerX: number, centerY: number): Float32Array {
    // Calculate total length of all lines
    let totalLength = 0;
    const lineLengths: number[] = [];

    for (const segment of shape) {
      if (segment.type === 'line') {
        const [p1, p2] = segment.points;
        const length = Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2));
        lineLengths.push(length);
        totalLength += length;
      }
    }

    // Distribute points proportionally along lines
    const allPoints: number[][] = [];
    let lineIndex = 0;

    for (const segment of shape) {
      if (segment.type === 'line') {
        const proportion = lineLengths[lineIndex] / totalLength;
        const pointsForLine = Math.max(2, Math.floor(totalPoints * proportion));
        const sampledPoints = sampleLine(segment.points[0], segment.points[1], pointsForLine);
        allPoints.push(...sampledPoints);
        lineIndex++;
      }
    }

    // Create positions array
    const positions = new Float32Array(totalPoints * 3);

    for (let i = 0; i < totalPoints; i++) {
      const pointIndex = i % allPoints.length;
      const point = allPoints[pointIndex];

      // Add slight random offset for organic feel
      const noise = 0.5;
      positions[i * 3] = (point[0] - centerX) * scale + (Math.random() - 0.5) * noise * scale;
      positions[i * 3 + 1] = -(point[1] - centerY) * scale + (Math.random() - 0.5) * noise * scale;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 0.3; // Slight depth variation
    }

    return positions;
  }

  // Initialize scene
  const container = document.getElementById('svg-particles-container');

  if (container) {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({
      alpha: true,
      antialias: true,
      powerPreference: 'high-performance'
    });

    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // Particle configuration
    const particleCount = 3000;
    const shapes = Object.keys(svgShapes) as (keyof typeof svgShapes)[];
    let currentShapeIndex = 0;

    // Generate initial positions
    const currentPositions = generateShapePoints(
      svgShapes[shapes[currentShapeIndex]],
      particleCount,
      0.025,
      50, 50
    );
    const targetPositions = new Float32Array(particleCount * 3);
    targetPositions.set(currentPositions);

    // Create geometry
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));

    // Simple point material - small discrete particles
    const material = new THREE.PointsMaterial({
      size: 0.02,
      color: 0xffffff,
      transparent: true,
      opacity: 0.9,
      sizeAttenuation: true,
      depthWrite: false
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    camera.position.z = 4;

    // Mouse interaction
    let mouseX = 0;
    let mouseY = 0;

    container.addEventListener('mousemove', (event) => {
      const rect = container.getBoundingClientRect();
      mouseX = ((event.clientX - rect.left) / rect.width - 0.5) * 2;
      mouseY = -((event.clientY - rect.top) / rect.height - 0.5) * 2;
    });

    // Morph to next shape
    function morphToShape(shapeKey: keyof typeof svgShapes) {
      const newPositions = generateShapePoints(svgShapes[shapeKey], particleCount, 0.025, 50, 50);
      targetPositions.set(newPositions);
    }

    // Switch shapes every 3 seconds
    setInterval(() => {
      currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
      morphToShape(shapes[currentShapeIndex]);
    }, 3000);

    // Animation
    let time = 0;
    const positionAttribute = geometry.getAttribute('position') as THREE.BufferAttribute;
    const positions = positionAttribute.array as Float32Array;

    function animate() {
      requestAnimationFrame(animate);
      time += 0.016;

      // Smooth rotation based on mouse
      particles.rotation.y += (mouseX * 0.5 - particles.rotation.y) * 0.02;
      particles.rotation.x += (mouseY * 0.3 - particles.rotation.x) * 0.02;

      // Gentle auto-rotation
      particles.rotation.y += 0.002;

      // Morph particles towards target positions
      for (let i = 0; i < particleCount * 3; i++) {
        const diff = targetPositions[i] - positions[i];
        positions[i] += diff * 0.03; // Smooth interpolation
      }
      positionAttribute.needsUpdate = true;

      renderer.render(scene, camera);
    }

    animate();

    // Handle resize
    const handleResize = () => {
      if (container.clientWidth === 0 || container.clientHeight === 0) return;
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    };

    window.addEventListener('resize', handleResize);

    // Cleanup on page navigation
    document.addEventListener('astro:before-swap', () => {
      window.removeEventListener('resize', handleResize);
      renderer.dispose();
      geometry.dispose();
      material.dispose();
    });
  }
</script>
