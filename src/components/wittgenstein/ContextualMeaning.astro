---
import InteractiveContainer from '../InteractiveContainer.astro'
---

<InteractiveContainer
  title="意義即使用 (Meaning is Use)"
  description="詞語沒有固定的核心，只有流動的邊界。試著點擊下面的按鈕，觀察「意思」這個詞如何在不同的語境中變形。"
>
  <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
    <div class="flex flex-col gap-3">
      <button
        class="context-btn group relative px-5 py-4 rounded-lg border border-stone-300 dark:border-stone-600 hover:border-primary-500 dark:hover:border-primary-500 bg-white dark:bg-stone-800 transition-all text-left overflow-hidden"
        data-context="interesting"
      >
        <div
          class="absolute inset-0 bg-primary-50 dark:bg-primary-900/20 opacity-0 group-hover:opacity-100 transition-opacity"
        >
        </div>
        <span class="relative z-10 font-medium text-stone-700 dark:text-stone-200"
          >這本書很有<span class="underline decoration-2 decoration-primary-500 underline-offset-4 font-bold">意思</span
          ></span
        >
      </button>

      <button
        class="context-btn group relative px-5 py-4 rounded-lg border border-stone-300 dark:border-stone-600 hover:border-primary-500 dark:hover:border-primary-500 bg-white dark:bg-stone-800 transition-all text-left overflow-hidden"
        data-context="sorry"
      >
        <div
          class="absolute inset-0 bg-primary-50 dark:bg-primary-900/20 opacity-0 group-hover:opacity-100 transition-opacity"
        >
        </div>
        <span class="relative z-10 font-medium text-stone-700 dark:text-stone-200"
          >真不好<span class="underline decoration-2 decoration-primary-500 underline-offset-4 font-bold">意思</span
          >，我遲到了</span
        >
      </button>

      <button
        class="context-btn group relative px-5 py-4 rounded-lg border border-stone-300 dark:border-stone-600 hover:border-primary-500 dark:hover:border-primary-500 bg-white dark:bg-stone-800 transition-all text-left overflow-hidden"
        data-context="gift"
      >
        <div
          class="absolute inset-0 bg-primary-50 dark:bg-primary-900/20 opacity-0 group-hover:opacity-100 transition-opacity"
        >
        </div>
        <span class="relative z-10 font-medium text-stone-700 dark:text-stone-200"
          >這是一點小<span class="underline decoration-2 decoration-primary-500 underline-offset-4 font-bold">意思</span
          >，請收下</span
        >
      </button>

      <button
        class="context-btn group relative px-5 py-4 rounded-lg border border-stone-300 dark:border-stone-600 hover:border-primary-500 dark:hover:border-primary-500 bg-white dark:bg-stone-800 transition-all text-left overflow-hidden"
        data-context="what"
      >
        <div
          class="absolute inset-0 bg-primary-50 dark:bg-primary-900/20 opacity-0 group-hover:opacity-100 transition-opacity"
        >
        </div>
        <span class="relative z-10 font-medium text-stone-700 dark:text-stone-200"
          >你這是什麼<span class="underline decoration-2 decoration-primary-500 underline-offset-4 font-bold">意思</span
          >？</span
        >
      </button>
    </div>

    <!-- Particle Canvas Display Area -->
    <div
      class="relative bg-stone-100 dark:bg-stone-900 rounded-lg border border-stone-200 dark:border-stone-800 flex flex-col items-center justify-center min-h-[280px]"
    >
      <canvas id="particle-canvas" class="w-full h-full absolute inset-0"></canvas>
      <p
        id="meaning-label"
        class="absolute bottom-6 text-lg font-bold text-stone-700 dark:text-stone-200 opacity-0 transition-all duration-500"
      >
      </p>
    </div>
  </div>
</InteractiveContainer>

<script>
  // SVG 路徑資料 - 使用簡化的路徑讓粒子更容易辨識
  const svgPaths: Record<string, { paths: string[]; label: string; viewBox: string }> = {
    interesting: {
      // 星星
      paths: ['M12 2l2.4 7.4h7.6l-6 4.6 2.3 7-6.3-4.6-6.3 4.6 2.3-7-6-4.6h7.6z'],
      label: '有趣',
      viewBox: '0 0 24 24',
    },
    sorry: {
      // 水滴
      paths: ['M12 2c0 0-7 8-7 13a7 7 0 0 0 14 0c0-5-7-13-7-13z'],
      label: '抱歉',
      viewBox: '0 0 24 24',
    },
    gift: {
      // 禮物盒
      paths: ['M4 8h16v12H4z', 'M12 8v12', 'M4 12h16', 'M8 8c0-2 1-3 2-3s2 1 2 3', 'M16 8c0-2-1-3-2-3s-2 1-2 3'],
      label: '心意',
      viewBox: '0 0 24 24',
    },
    what: {
      // 問號
      paths: ['M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2z', 'M9 9a3 3 0 1 1 4 2.83c-.5.29-1 .84-1 1.67v.5'],
      label: '意圖',
      viewBox: '0 0 24 24',
    },
  }

  // 粒子類別
  class Particle {
    x: number
    y: number
    targetX: number
    targetY: number
    size: number
    speed: number
    delay: number
    // 飄動參數
    driftPhaseX: number
    driftPhaseY: number
    driftSpeedX: number
    driftSpeedY: number
    driftAmplitude: number

    constructor(x: number, y: number) {
      this.x = x
      this.y = y
      this.targetX = x
      this.targetY = y
      this.size = 2.5 + Math.random() * 1.5
      this.speed = 0.04 + Math.random() * 0.03
      this.delay = Math.random() * 0.3
      // 每個粒子有獨立的飄動相位和速度
      this.driftPhaseX = Math.random() * Math.PI * 2
      this.driftPhaseY = Math.random() * Math.PI * 2
      this.driftSpeedX = 0.3 + Math.random() * 0.4
      this.driftSpeedY = 0.3 + Math.random() * 0.4
      this.driftAmplitude = 2 + Math.random() * 2
    }

    update(progress: number, time: number) {
      const adjustedProgress = Math.max(0, (progress - this.delay) / (1 - this.delay))

      // 計算飄動偏移
      const driftX = Math.sin(time * this.driftSpeedX + this.driftPhaseX) * this.driftAmplitude
      const driftY = Math.cos(time * this.driftSpeedY + this.driftPhaseY) * this.driftAmplitude

      if (adjustedProgress <= 0) {
        // 還沒開始移動時也要飄動
        this.x += (this.targetX + driftX - this.x) * 0.02
        this.y += (this.targetY + driftY - this.y) * 0.02
        return
      }

      const eased = this.easeOutCubic(Math.min(adjustedProgress, 1))
      // 往目標位置移動，但目標位置會因飄動而微微偏移
      this.x = this.x + (this.targetX + driftX - this.x) * eased * 0.15
      this.y = this.y + (this.targetY + driftY - this.y) * eased * 0.15
    }

    easeOutCubic(t: number): number {
      return 1 - (1 - t) ** 3
    }

    draw(ctx: CanvasRenderingContext2D, color: string) {
      ctx.beginPath()
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2)
      ctx.fillStyle = color
      ctx.fill()
    }

    setTarget(x: number, y: number) {
      this.targetX = x
      this.targetY = y
      this.delay = Math.random() * 0.2
    }
  }

  // 從 SVG 路徑取樣點
  function samplePointsFromPaths(
    paths: string[],
    viewBox: string,
    width: number,
    height: number,
    numPoints: number,
  ): Array<{ x: number; y: number }> {
    const points: Array<{ x: number; y: number }> = []

    // 解析 viewBox
    const [vbX, vbY, vbW, vbH] = viewBox.split(' ').map(Number)

    // 計算縮放和位移，讓圖形置中
    const scale = Math.min(width / vbW, height / vbH) * 0.6
    const offsetX = (width - vbW * scale) / 2
    const offsetY = (height - vbH * scale) / 2 - 20 // 稍微往上移給文字留空間

    // 創建臨時 SVG 來取樣路徑
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
    svg.setAttribute('viewBox', viewBox)

    paths.forEach((d) => {
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
      path.setAttribute('d', d)
      svg.appendChild(path)

      const pathLength = path.getTotalLength()
      const pointsPerPath = Math.ceil(numPoints / paths.length)
      const step = pathLength / pointsPerPath

      for (let i = 0; i < pointsPerPath; i++) {
        const point = path.getPointAtLength(i * step)
        points.push({
          x: (point.x - vbX) * scale + offsetX,
          y: (point.y - vbY) * scale + offsetY,
        })
      }
    })

    return points
  }

  function initContextualMeaning() {
    const canvas = document.getElementById('particle-canvas') as HTMLCanvasElement
    const buttons = document.querySelectorAll('.context-btn')
    const hintText = document.getElementById('hint-text')
    const meaningLabel = document.getElementById('meaning-label')

    if (!canvas)
return
    const ctx = canvas.getContext('2d')!
    if (!ctx)
return

    // 設定 canvas 尺寸
    let width = 0
    let height = 0
    function resize() {
      const rect = canvas.getBoundingClientRect()
      const dpr = window.devicePixelRatio || 1
      width = rect.width
      height = rect.height
      canvas.width = width * dpr
      canvas.height = height * dpr
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
    }
    resize()
    window.addEventListener('resize', resize)

    // 取得粒子顏色
    function getParticleColor(): string {
      return document.documentElement.classList.contains('dark')
        ? 'rgb(168, 162, 158)' // stone-400
        : 'rgb(87, 83, 78)' // stone-600
    }

    // 初始化粒子
    const PARTICLE_COUNT = 150
    const particles: Particle[] = []
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      particles.push(new Particle(width / 2 + (Math.random() - 0.5) * 100, height / 2 + (Math.random() - 0.5) * 100))
    }

    let currentKey: string | null = null
    let animationProgress = 0
    let isAnimating = false
    let time = 0

    // 變形到新形狀
    function morphToShape(key: string) {
      if (key === currentKey)
return
      currentKey = key

      const data = svgPaths[key]
      if (!data)
return

      const targetPoints = samplePointsFromPaths(data.paths, data.viewBox, width, height, PARTICLE_COUNT)

      // 為每個粒子分配新目標位置
      particles.forEach((particle, i) => {
        const target = targetPoints[i % targetPoints.length]
        // 加入微量隨機偏移讓形狀更有機
        particle.setTarget(target.x + (Math.random() - 0.5) * 4, target.y + (Math.random() - 0.5) * 4)
      })

      animationProgress = 0
      isAnimating = true
    }

    // 動畫循環
    function animate() {
      ctx.clearRect(0, 0, width, height)

      time += 0.016

      if (isAnimating) {
        animationProgress += 0.016
        if (animationProgress >= 1.5) {
          isAnimating = false
        }
      }

      const color = getParticleColor()
      particles.forEach((p) => {
        p.update(animationProgress, time)
        p.draw(ctx, color)
      })

      requestAnimationFrame(animate)
    }
    animate()

    // 按鈕點擊事件
    buttons.forEach((btn) => {
      btn.addEventListener('click', () => {
        const key = btn.getAttribute('data-context')
        if (!key || !svgPaths[key])
return

        // 隱藏提示文字
        if (hintText) {
          hintText.style.opacity = '0'
        }

        // 更新按鈕樣式
        buttons.forEach((b) => {
          b.classList.remove('ring-2', 'ring-primary-500', 'bg-primary-50', 'dark:bg-primary-900/20')
        })
        btn.classList.add('ring-2', 'ring-primary-500', 'bg-primary-50', 'dark:bg-primary-900/20')

        // 變形到新形狀
        morphToShape(key)

        // 更新文字標籤
        if (meaningLabel) {
          meaningLabel.style.opacity = '0'
          meaningLabel.style.transform = 'translateY(10px)'
          setTimeout(() => {
            meaningLabel.textContent = svgPaths[key].label
            meaningLabel.style.opacity = '1'
            meaningLabel.style.transform = 'translateY(0)'
          }, 400)
        }
      })
    })
  }

  // 頁面載入時初始化
  initContextualMeaning()

  // Swup 頁面轉換後重新初始化
  document.addEventListener('swup:contentReplaced', () => {
    initContextualMeaning()
  })
</script>

<style>
  #particle-canvas {
    display: block;
  }

  #hint-text {
    transition: opacity 0.3s ease;
    pointer-events: none;
  }

  #meaning-label {
    transition: all 0.4s ease;
  }
</style>
