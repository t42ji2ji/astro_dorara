---

---

<aside class="reading-progress-sidebar">
  <!-- Reading Progress Bar -->
  <div class="progress-container hidden lg:block">
    <div class="text-xs font-bold text-stone-500 dark:text-stone-400 mb-2 uppercase tracking-wider">
      閱讀進度 <span id="progress-text" class="progress-text">0%</span>
    </div>
    <div class="progress-bar-bg">
      <div id="progress-bar" class="progress-bar-fill"></div>
    </div>
  </div>

  <!-- Table of Contents -->
  <div class="toc-container">
    <div class="text-xs font-bold text-stone-500 dark:text-stone-400 mb-3 uppercase tracking-wider">目錄</div>
    <nav id="toc-nav" class="toc-nav">
      <!-- TOC will be populated by JavaScript -->
    </nav>
  </div>
  <div class="lg:hidden h-16"></div>
</aside>

<script>
  function initReadingProgress() {
    const progressBar = document.getElementById('progress-bar')
    const progressText = document.getElementById('progress-text')
    const tocNav = document.getElementById('toc-nav')
    const article = document.querySelector('article.prose')

    if (!progressBar || !progressText || !tocNav || !article) 
return

    // Generate Table of Contents
    const headings = article.querySelectorAll('h1, h2, h3, h4')
    const tocItems: { element: Element; link: HTMLAnchorElement }[] = []

    // Group headings by parent (h1/h2)
    let currentParent: HTMLAnchorElement | null = null
    const childrenMap = new Map<HTMLAnchorElement, HTMLAnchorElement[]>()

    headings.forEach((heading, index) => {
      // Add ID to heading if not present
      if (!heading.id) {
        heading.id = `heading-${index}`
      }

      const level = Number.parseInt(heading.tagName.substring(1))
      const link = document.createElement('a')
      link.href = `#${heading.id}`
      link.className = `toc-link toc-level-${level}`
      link.dataset.target = heading.id

      // Check if heading is inside an InteractiveContainer
      const isInteractive = heading.closest('.interactive-container') !== null

      if (isInteractive) {
        // Add green dot indicator for interactive sections
        const dot = document.createElement('span')
        dot.className = 'toc-interactive-dot'
        link.appendChild(dot)
      }

      const text = document.createTextNode(heading.textContent || '')
      link.appendChild(text)

      // Track parent-child relationships
      if (level <= 2) {
        currentParent = link
        childrenMap.set(link, [])
      } else if (currentParent) {
        // h3/h4 are children, hide by default
        link.classList.add('toc-child', 'toc-collapsed')
        childrenMap.get(currentParent)?.push(link)
        // Mark parent as having children
        currentParent.classList.add('toc-has-children')
      }

      tocNav.appendChild(link)
      tocItems.push({ element: heading, link })

      // Click handler for h1/h2 to toggle children
      if (level <= 2) {
        link.addEventListener('click', (e) => {
          e.preventDefault()
          const children = childrenMap.get(link) || []
          const isExpanded = link.classList.contains('toc-expanded')

          // Collapse all other expanded sections
          childrenMap.forEach((childLinks, parentLink) => {
            if (parentLink !== link && parentLink.classList.contains('toc-expanded')) {
              parentLink.classList.remove('toc-expanded')
              childLinks.forEach(child => child.classList.add('toc-collapsed'))
            }
          })

          // Toggle current section
          if (isExpanded) {
            link.classList.remove('toc-expanded')
            children.forEach(child => child.classList.add('toc-collapsed'))
          } else {
            link.classList.add('toc-expanded')
            children.forEach(child => child.classList.remove('toc-collapsed'))
          }

          // Scroll to heading
          const main = document.querySelector('main')
          if (!main) return

          let headingTop = 0
          let element: HTMLElement | null = heading as HTMLElement
          while (element && element !== main) {
            headingTop += element.offsetTop
            element = element.offsetParent as HTMLElement | null
          }

          const viewportHeight = main.clientHeight
          const offset = viewportHeight * 0.3
          const targetScroll = headingTop - offset

          main.scrollTo({ top: targetScroll, behavior: 'smooth' })
        })
      } else {
        // h3/h4 just scroll
        link.addEventListener('click', (e) => {
          e.preventDefault()
          const main = document.querySelector('main')
          if (!main) return

          let headingTop = 0
          let element: HTMLElement | null = heading as HTMLElement
          while (element && element !== main) {
            headingTop += element.offsetTop
            element = element.offsetParent as HTMLElement | null
          }

          const viewportHeight = main.clientHeight
          const offset = viewportHeight * 0.3
          const targetScroll = headingTop - offset

          main.scrollTo({ top: targetScroll, behavior: 'smooth' })
        })
      }
    })

    // Update progress on scroll
    function updateProgress() {
      const main = document.querySelector('main')
      if (!main) 
return

      const scrollTop = main.scrollTop
      const scrollHeight = main.scrollHeight - main.clientHeight
      const progress = scrollHeight > 0 ? (scrollTop / scrollHeight) * 100 : 0

      if (progressBar)
progressBar.style.width = `${progress}%`
      if (progressText)
progressText.textContent = `${Math.round(progress)}%`

      // Update active TOC item
      let activeIndex = -1
      for (let i = headings.length - 1; i >= 0; i--) {
        const heading = headings[i] as HTMLElement
        // Calculate cumulative offsetTop for nested elements
        let headingTop = 0
        let el: HTMLElement | null = heading
        while (el && el !== main) {
          headingTop += el.offsetTop
          el = el.offsetParent as HTMLElement | null
        }
        if (headingTop <= scrollTop + 100) {
          activeIndex = i
          break
        }
      }

      tocItems.forEach((item, index) => {
        if (index === activeIndex) {
          item.link.classList.add('active')
        } else {
          item.link.classList.remove('active')
        }
      })
    }

    const main = document.querySelector('main')
    if (main) {
      main.addEventListener('scroll', updateProgress)
      updateProgress() // Initial call
    }
  }

  // Initialize on page load
  initReadingProgress()

  // Re-initialize after page transitions (if using Swup or similar)
  document.addEventListener('astro:page-load', initReadingProgress)
</script>

<style>
  .reading-progress-sidebar {
    display: flex;
    flex-direction: column;
    gap: 2rem;
    position: sticky;
    top: 5rem;
    max-height: calc(100vh - 6rem);
    overflow-y: auto;
  }

  .progress-container {
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--uno-colors-stone-200);
  }

  :global(.dark) .progress-container {
    border-bottom-color: var(--uno-colors-stone-700);
  }

  .progress-bar-bg {
    width: 100%;
    height: 8px;
    background-color: transparent;
    border-radius: 9999px;
    overflow: hidden;
    margin-bottom: 0.5rem;
  }

  :global(.dark) .progress-bar-bg {
    background-color: transparent;
  }

  .progress-bar-fill {
    height: 100%;
    background: var(--uno-colors-primary);
    width: 0%;
    transition: width 0.2s ease-out;
    border-radius: 9999px;
  }

  .progress-text {
    text-align: center;
    font-size: 0.75rem;
    font-weight: 600;
    color: var(--uno-colors-stone-600);
  }

  :global(.dark) .progress-text {
    color: var(--uno-colors-stone-400);
  }

  .toc-container {
    flex: 1;
    overflow-y: auto;
  }

  .toc-nav {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  :global(.toc-link) {
    font-size: 0.875rem;
    color: var(--uno-colors-stone-600);
    text-decoration: none !important;
    padding: 0.375rem 0.75rem;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 0.375rem;
  }

  :global(.toc-interactive-dot) {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background-color: #22c55e;
    animation: pulse 2s ease-in-out infinite;
    flex-shrink: 0;
  }

  @keyframes pulse {
    0%,
    100% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
  }

  :global(.dark .toc-link) {
    color: var(--uno-colors-stone-400);
  }

  :global(.toc-link:hover) {
    text-decoration: underline !important;
    text-underline-offset: 3px;
  }

  :global(.dark .toc-link:hover) {
    text-decoration: underline !important;
  }

  :global(.toc-link.active) {
    color: var(--uno-colors-purple-600);
    text-decoration: underline !important;
    text-underline-offset: 3px;
  }

  :global(.dark .toc-link.active) {
    color: var(--uno-colors-purple-400);
  }

  :global(.toc-link.toc-level-1) {
    font-weight: 500;
  }

  :global(.toc-link.toc-level-2) {
    color: var(--uno-colors-stone-500);
  }

  :global(.dark .toc-link.toc-level-2) {
    color: var(--uno-colors-stone-500);
  }

  :global(.toc-link.toc-level-3) {
    padding-left: 1.25rem;
    font-size: 0.8125rem;
    color: var(--uno-colors-stone-400);
  }

  :global(.toc-link.toc-level-3)::before {
    content: '└';
    margin-right: 0.25rem;
    color: var(--uno-colors-stone-300);
  }

  :global(.dark .toc-link.toc-level-3)::before {
    color: var(--uno-colors-stone-600);
  }

  :global(.dark .toc-link.toc-level-3) {
    color: var(--uno-colors-stone-500);
  }

  :global(.toc-link.toc-level-4) {
    padding-left: 1.75rem;
    font-size: 0.75rem;
    color: var(--uno-colors-stone-400);
  }

  :global(.toc-link.toc-level-4)::before {
    content: '└';
    margin-right: 0.25rem;
    color: var(--uno-colors-stone-300);
  }

  :global(.dark .toc-link.toc-level-4)::before {
    color: var(--uno-colors-stone-600);
  }

  :global(.dark .toc-link.toc-level-4) {
    color: var(--uno-colors-stone-600);
  }

  /* Collapsible children */
  :global(.toc-collapsed) {
    display: none;
  }

  :global(.toc-link.toc-level-1),
  :global(.toc-link.toc-level-2) {
    cursor: pointer;
  }

  :global(.toc-has-children)::after {
    content: '';
    display: inline-block;
    width: 0;
    height: 0;
    margin-left: 0.5rem;
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
    border-left: 4px solid currentColor;
    opacity: 0.4;
    transition: transform 0.2s ease;
  }

  :global(.toc-expanded)::after {
    transform: rotate(90deg);
    opacity: 0.6;
  }

  /* Custom scrollbar for TOC */
  .toc-container {
    scrollbar-width: thin;
    scrollbar-color: transparent transparent;
  }

  :global(.dark) .toc-container {
    scrollbar-color: transparent transparent;
  }

  .toc-container::-webkit-scrollbar {
    width: 4px;
  }

  .toc-container::-webkit-scrollbar-track {
    background: transparent;
  }

  .toc-container::-webkit-scrollbar-thumb {
    background-color: transparent;
    border-radius: 9999px;
  }

  :global(.dark) .toc-container::-webkit-scrollbar-thumb {
    background-color: transparent;
  }
</style>
