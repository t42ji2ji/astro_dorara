---
import LayoutMinimal from '~/layouts/LayoutMinimal.astro'
---

<LayoutMinimal>
  <div class="page-404">
    <canvas id="pixel-canvas"></canvas>
    <div class="content">
      <p class="message">頁面不存在</p>
      <p class="redirect-text">
        <span id="countdown">5</span> 秒後返回首頁
      </p>
      <a href="/" class="home-link">立即返回</a>
    </div>
  </div>
</LayoutMinimal>

<style>
  .page-404 {
    position: relative;
    width: 100%;
    height: calc(100vh - 10rem);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  #pixel-canvas {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -55%);
    z-index: 0;
  }

  .content {
    position: relative;
    z-index: 1;
    text-align: center;
    margin-top: 200px;
  }

  .message {
    font-size: 0.875rem;
    color: #78716c;
    margin-bottom: 0.5rem;
  }

  :global(.dark) .message {
    color: #a8a29e;
  }

  .redirect-text {
    font-size: 0.75rem;
    color: #a8a29e;
    margin-bottom: 1.5rem;
  }

  :global(.dark) .redirect-text {
    color: #78716c;
  }

  #countdown {
    font-variant-numeric: tabular-nums;
  }

  .home-link {
    display: inline-block;
    padding: 0.5rem 1.5rem;
    border: 1px solid currentColor;
    color: #78716c;
    text-decoration: none;
    font-size: 0.875rem;
    transition: all 0.2s ease;
  }

  .home-link:hover {
    background: #78716c;
    color: white;
  }

  :global(.dark) .home-link {
    color: #a8a29e;
  }

  :global(.dark) .home-link:hover {
    background: #a8a29e;
    color: #1c1917;
  }
</style>

<script>
  import * as THREE from 'three'

  // Countdown redirect
  let countdown = 5
  const countdownEl = document.getElementById('countdown')

  const timer = setInterval(() => {
    countdown--
    if (countdownEl) countdownEl.textContent = String(countdown)
    if (countdown <= 0) {
      clearInterval(timer)
      window.location.replace('/')
    }
  }, 1000)

  // Pixel 404 pattern (each digit is 5x7 pixels)
  const digit4 = [
    [1,0,0,1,0],
    [1,0,0,1,0],
    [1,0,0,1,0],
    [1,1,1,1,1],
    [0,0,0,1,0],
    [0,0,0,1,0],
    [0,0,0,1,0],
  ]

  const digit0 = [
    [0,1,1,1,0],
    [1,0,0,0,1],
    [1,0,0,0,1],
    [1,0,0,0,1],
    [1,0,0,0,1],
    [1,0,0,0,1],
    [0,1,1,1,0],
  ]

  class Pixel404 {
    canvas: HTMLCanvasElement
    renderer!: THREE.WebGLRenderer
    scene!: THREE.Scene
    camera!: THREE.PerspectiveCamera
    pixels: THREE.Mesh[] = []
    originalPositions: THREE.Vector3[] = []
    mouse!: THREE.Vector2
    raycaster!: THREE.Raycaster
    time: number = 0
    isDark!: boolean
    isClicking: boolean = false
    clickTime: number = 0
    velocities: THREE.Vector3[] = []

    constructor() {
      this.canvas = document.getElementById('pixel-canvas') as HTMLCanvasElement
      if (!this.canvas) return

      this.mouse = new THREE.Vector2(9999, 9999)
      this.raycaster = new THREE.Raycaster()
      this.isDark = document.documentElement.classList.contains('dark')

      this.init()
      this.createPixels()
      this.setupEvents()
      this.animate()
    }

    init() {
      const width = Math.min(600, window.innerWidth - 40)
      const height = 300

      this.renderer = new THREE.WebGLRenderer({
        canvas: this.canvas,
        alpha: true,
        antialias: true
      })
      this.renderer.setSize(width, height)
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

      this.scene = new THREE.Scene()

      this.camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000)
      this.camera.position.z = 20

      // Ambient light
      const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.6)
      this.scene.add(ambientLight)

      // Directional light
      const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.8)
      directionalLight.position.set(5, 5, 5)
      this.scene.add(directionalLight)
    }

    createPixels() {
      const pixelSize = 0.8
      const gap = 0.15
      const digitSpacing = 2

      // Colors based on theme
      const baseColor = this.isDark ? 0xA8A29E : 0x78716C
      const accentColor = this.isDark ? 0x57534E : 0xD6D3D1

      const geometry = new THREE.BoxGeometry(pixelSize, pixelSize, pixelSize)

      const patterns = [digit4, digit0, digit4]
      const offsetX = -((patterns.length * 5 + (patterns.length - 1) * digitSpacing) * (pixelSize + gap)) / 2

      patterns.forEach((pattern, digitIndex) => {
        const digitOffset = digitIndex * (5 * (pixelSize + gap) + digitSpacing)

        pattern.forEach((row, rowIndex) => {
          row.forEach((pixel, colIndex) => {
            if (pixel === 1) {
              const material = new THREE.MeshLambertMaterial({
                color: Math.random() > 0.8 ? accentColor : baseColor,
              })

              const mesh = new THREE.Mesh(geometry, material)

              const x = offsetX + digitOffset + colIndex * (pixelSize + gap)
              const y = (3 - rowIndex) * (pixelSize + gap)
              const z = 0

              mesh.position.set(x, y, z)

              // Store original position and velocity
              this.originalPositions.push(new THREE.Vector3(x, y, z))
              this.velocities.push(new THREE.Vector3(0, 0, 0))

              // Random initial offset for entrance animation
              mesh.position.z = -50 + Math.random() * 20
              mesh.rotation.x = Math.random() * Math.PI
              mesh.rotation.y = Math.random() * Math.PI

              this.pixels.push(mesh)
              this.scene.add(mesh)
            }
          })
        })
      })
    }

    setupEvents() {
      window.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect()
        this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1
        this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1
      })

      window.addEventListener('mouseleave', () => {
        this.mouse.set(9999, 9999)
      })

      // Click explosion effect
      this.canvas.addEventListener('mousedown', () => {
        this.isClicking = true
        this.clickTime = this.time
      })

      this.canvas.addEventListener('mouseup', () => {
        this.isClicking = false
      })

      window.addEventListener('resize', () => {
        const width = Math.min(600, window.innerWidth - 40)
        const height = 300
        this.renderer.setSize(width, height)
        this.camera.aspect = width / height
        this.camera.updateProjectionMatrix()
      })

      // Watch for theme changes
      const observer = new MutationObserver(() => {
        const newIsDark = document.documentElement.classList.contains('dark')
        if (newIsDark !== this.isDark) {
          this.isDark = newIsDark
          this.updateColors()
        }
      })
      observer.observe(document.documentElement, { attributes: true, attributeFilter: ['class'] })
    }

    updateColors() {
      const baseColor = this.isDark ? 0xA8A29E : 0x78716C
      const accentColor = this.isDark ? 0x57534E : 0xD6D3D1

      this.pixels.forEach((pixel) => {
        const material = pixel.material as THREE.MeshLambertMaterial
        material.color.setHex(Math.random() > 0.8 ? accentColor : baseColor)
      })
    }

    animate = () => {
      this.time += 0.016

      // Update raycaster
      this.raycaster.setFromCamera(this.mouse, this.camera)

      const mousePos3D = new THREE.Vector3(this.mouse.x * 10, this.mouse.y * 6, 5)

      this.pixels.forEach((pixel, index) => {
        const original = this.originalPositions[index]
        const velocity = this.velocities[index]
        const material = pixel.material as THREE.MeshLambertMaterial

        // Entrance animation
        if (this.time < 2) {
          const progress = Math.min(this.time / 1.5, 1)
          const eased = 1 - (1 - progress) ** 3

          pixel.position.z = THREE.MathUtils.lerp(pixel.position.z, original.z, eased * 0.1)
          pixel.rotation.x *= 0.95
          pixel.rotation.y *= 0.95
        }

        // Floating animation
        const floatOffset = Math.sin(this.time * 2 + index * 0.5) * 0.15
        const targetY = original.y + floatOffset

        // Mouse interaction
        const pixelPos = new THREE.Vector3(pixel.position.x, pixel.position.y, pixel.position.z)
        const distance = pixelPos.distanceTo(mousePos3D)

        // Click explosion - much stronger!
        if (this.isClicking && distance < 12) {
          const explosionForce = ((12 - distance) / 12) ** 0.5 * 3
          const direction = pixelPos.clone().sub(mousePos3D).normalize()

          // Add randomness for more chaotic explosion
          const randomX = (Math.random() - 0.5) * 0.5
          const randomY = (Math.random() - 0.5) * 0.5
          const randomZ = Math.random() * 0.3

          velocity.x += (direction.x + randomX) * explosionForce
          velocity.y += (direction.y + randomY) * explosionForce
          velocity.z += (direction.z + randomZ) * explosionForce

          // Strong rotation on explosion
          pixel.rotation.x += (Math.random() - 0.5) * explosionForce * 0.5
          pixel.rotation.y += (Math.random() - 0.5) * explosionForce * 0.5
          pixel.rotation.z += (Math.random() - 0.5) * explosionForce * 0.5
        }

        // Mouse repulsion (hover)
        if (distance < 5) {
          const force = (5 - distance) / 5
          const direction = pixelPos.clone().sub(mousePos3D).normalize()

          velocity.x += direction.x * force * 0.15
          velocity.y += direction.y * force * 0.15
          velocity.z += direction.z * force * 0.1

          // Add rotation when near mouse
          pixel.rotation.x += force * 0.08
          pixel.rotation.y += force * 0.08

          // Brighten color when near mouse
          const brightness = 1 + force * 0.3
          material.color.setRGB(
            material.color.r * brightness,
            material.color.g * brightness,
            material.color.b * brightness
          )
        } else {
          // Reset color
          const baseColor = this.isDark ? 0xA8A29E : 0x78716C
          material.color.setHex(baseColor)
        }

        // Apply velocity with damping (less damping = more momentum)
        velocity.multiplyScalar(0.95)

        // Spring force back to original position (weaker = fly further)
        const springForce = 0.04
        velocity.x += (original.x - pixel.position.x) * springForce
        velocity.y += (targetY - pixel.position.y) * springForce
        velocity.z += (original.z - pixel.position.z) * springForce

        // Update position
        pixel.position.x += velocity.x
        pixel.position.y += velocity.y
        pixel.position.z += velocity.z

        // Slowly reset rotation (slower = more spin visible)
        pixel.rotation.x *= 0.98
        pixel.rotation.y *= 0.98
        pixel.rotation.z *= 0.98
      })

      this.renderer.render(this.scene, this.camera)
      requestAnimationFrame(this.animate)
    }
  }

  // Initialize
  const pixel404 = new Pixel404()
  void pixel404
</script>
