---
import LayoutMinimal from '~/layouts/LayoutMinimal.astro'
---

<LayoutMinimal>
  <div class="page-404">
    <canvas id="glitch-canvas"></canvas>
    <div class="content">
      <p class="text-sm text-stone-500 dark:text-stone-400 mb-6">找不到這個頁面</p>
      <a href="/" class="home-link">返回首頁</a>
    </div>
  </div>
</LayoutMinimal>

<style>
  .page-404 {
    position: relative;
    width: 100%;
    height: calc(100vh - 10rem);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  #glitch-canvas {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 0;
  }

  .content {
    position: relative;
    z-index: 1;
    text-align: center;
    margin-top: 180px;
  }

  .home-link {
    display: inline-block;
    padding: 0.5rem 1.5rem;
    border: 1px solid currentColor;
    color: var(--text-color, #78716c);
    text-decoration: none;
    transition: all 0.2s ease;
  }

  .home-link:hover {
    background: var(--text-color, #78716c);
    color: white;
  }

  :global(.dark) .home-link {
    --text-color: #a8a29e;
  }
</style>

<script>
  import * as THREE from 'three'

  const vertexShader = `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `

  const fragmentShader = `
    uniform float uTime;
    uniform vec2 uResolution;
    uniform vec2 uMouse;

    varying vec2 vUv;

    // Hash function for randomness
    float hash(vec2 p) {
      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
    }

    // 2D noise
    float noise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      f = f * f * (3.0 - 2.0 * f);

      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));

      return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
    }

    // FBM for organic movement
    float fbm(vec2 p) {
      float value = 0.0;
      float amplitude = 0.5;
      for (int i = 0; i < 5; i++) {
        value += amplitude * noise(p);
        p *= 2.0;
        amplitude *= 0.5;
      }
      return value;
    }

    // SDF for digit segments (7-segment style)
    float segment(vec2 p, vec2 a, vec2 b, float w) {
      vec2 pa = p - a;
      vec2 ba = b - a;
      float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
      return length(pa - ba * h) - w;
    }

    // Draw a "4" digit
    float digit4(vec2 p, float w) {
      float d = 1e10;
      // Vertical left (top half)
      d = min(d, segment(p, vec2(-0.3, 0.5), vec2(-0.3, 0.0), w));
      // Horizontal middle
      d = min(d, segment(p, vec2(-0.3, 0.0), vec2(0.3, 0.0), w));
      // Vertical right (full)
      d = min(d, segment(p, vec2(0.2, 0.5), vec2(0.2, -0.5), w));
      return d;
    }

    // Draw a "0" digit
    float digit0(vec2 p, float w) {
      float d = 1e10;
      // Top
      d = min(d, segment(p, vec2(-0.25, 0.5), vec2(0.25, 0.5), w));
      // Bottom
      d = min(d, segment(p, vec2(-0.25, -0.5), vec2(0.25, -0.5), w));
      // Left
      d = min(d, segment(p, vec2(-0.25, 0.5), vec2(-0.25, -0.5), w));
      // Right
      d = min(d, segment(p, vec2(0.25, 0.5), vec2(0.25, -0.5), w));
      return d;
    }

    // Full 404 text
    float text404(vec2 p) {
      float w = 0.04;
      float d = 1e10;

      // First 4
      d = min(d, digit4(p + vec2(1.0, 0.0), w));
      // 0
      d = min(d, digit0(p, w));
      // Second 4
      d = min(d, digit4(p - vec2(1.0, 0.0), w));

      return d;
    }

    void main() {
      vec2 uv = vUv;
      vec2 center = vec2(0.5);

      // Aspect ratio correction
      vec2 p = (uv - center) * vec2(uResolution.x / uResolution.y, 1.0) * 3.0;

      // Mouse influence - subtle distortion toward mouse
      vec2 mouseOffset = (uMouse - center) * 0.3;
      float mouseDist = length(uv - uMouse);
      float mouseInfluence = smoothstep(0.5, 0.0, mouseDist) * 0.15;

      // Time-based distortion
      float t = uTime * 0.5;

      // Organic flowing distortion
      vec2 distort = vec2(
        fbm(p * 1.5 + t * 0.3) - 0.5,
        fbm(p * 1.5 + t * 0.3 + 100.0) - 0.5
      ) * 0.4;

      // Add mouse-reactive distortion
      distort += mouseOffset * mouseInfluence;

      // Glitch offset (occasional horizontal shifts)
      float glitchTime = floor(uTime * 3.0);
      float glitchRand = hash(vec2(glitchTime, 0.0));
      float glitchActive = step(0.85, glitchRand);
      float glitchOffset = (hash(vec2(floor(p.y * 10.0), glitchTime)) - 0.5) * 0.3 * glitchActive;

      vec2 distortedP = p + distort + vec2(glitchOffset, 0.0);

      // Calculate distance to 404 text
      float d = text404(distortedP);

      // Create fragmented/dissolved edges
      float dissolve = fbm(p * 8.0 + t * 0.2) * 0.15;
      d += dissolve * 0.5;

      // Color based on distance
      float alpha = 1.0 - smoothstep(0.0, 0.08, d);

      // Chromatic aberration for glitch feel
      float dR = text404(distortedP + vec2(0.02, 0.0) * (1.0 + glitchActive));
      float dB = text404(distortedP - vec2(0.02, 0.0) * (1.0 + glitchActive));

      float alphaR = 1.0 - smoothstep(0.0, 0.08, dR + dissolve * 0.5);
      float alphaB = 1.0 - smoothstep(0.0, 0.08, dB + dissolve * 0.5);

      // Base colors - stone palette
      vec3 baseColor = vec3(0.47, 0.44, 0.40); // stone-500ish
      vec3 glitchColor = vec3(0.65, 0.62, 0.58); // lighter stone

      // Combine with chromatic aberration
      vec3 color = vec3(0.0);
      color.r = mix(0.0, baseColor.r, alphaR);
      color.g = mix(0.0, baseColor.g, alpha);
      color.b = mix(0.0, baseColor.b, alphaB);

      // Add subtle glow
      float glow = 1.0 - smoothstep(0.0, 0.5, d);
      color += glitchColor * glow * 0.1;

      // Scanlines
      float scanline = sin(uv.y * uResolution.y * 0.5) * 0.03;
      color -= scanline;

      // Final alpha
      float finalAlpha = max(max(alphaR, alpha), alphaB) + glow * 0.15;

      gl_FragColor = vec4(color, finalAlpha * 0.9);
    }
  `

  class Glitch404 {
    canvas: HTMLCanvasElement
    renderer: THREE.WebGLRenderer
    scene: THREE.Scene
    camera: THREE.OrthographicCamera
    material: THREE.ShaderMaterial
    mouse: THREE.Vector2
    startTime: number

    constructor() {
      this.canvas = document.getElementById('glitch-canvas') as HTMLCanvasElement
      this.startTime = Date.now()
      this.mouse = new THREE.Vector2(0.5, 0.5)

      const width = Math.min(600, window.innerWidth - 40)
      const height = 300

      this.renderer = new THREE.WebGLRenderer({
        canvas: this.canvas,
        alpha: true,
        antialias: true
      })
      this.renderer.setSize(width, height)
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

      this.scene = new THREE.Scene()
      this.camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0.1, 10)
      this.camera.position.z = 1

      this.material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        transparent: true,
        uniforms: {
          uTime: { value: 0 },
          uResolution: { value: new THREE.Vector2(width, height) },
          uMouse: { value: this.mouse }
        }
      })

      const geometry = new THREE.PlaneGeometry(1, 1)
      const mesh = new THREE.Mesh(geometry, this.material)
      this.scene.add(mesh)

      this.setupEvents()
      this.animate()
    }

    setupEvents() {
      window.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect()
        this.mouse.x = (e.clientX - rect.left) / rect.width
        this.mouse.y = 1.0 - (e.clientY - rect.top) / rect.height
      })

      window.addEventListener('resize', () => {
        const width = Math.min(600, window.innerWidth - 40)
        const height = 300
        this.renderer.setSize(width, height)
        this.material.uniforms.uResolution.value.set(width, height)
      })
    }

    animate = () => {
      const elapsed = (Date.now() - this.startTime) / 1000
      this.material.uniforms.uTime.value = elapsed
      this.renderer.render(this.scene, this.camera)
      requestAnimationFrame(this.animate)
    }
  }

  new Glitch404()
</script>
