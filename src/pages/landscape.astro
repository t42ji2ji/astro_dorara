---
// Landscape Shader - Based on Inigo Quilez's Rainforest
// Interactive mathematical painting with adjustable parameters
---

<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Landscape - Mathematical Painting</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        overflow: hidden;
        background: #1a1a1a;
        font-family: system-ui, -apple-system, sans-serif;
      }

      #canvas {
        width: 100vw;
        height: 100vh;
        display: block;
      }

      /* Control panel toggle button */
      .panel-toggle {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: rgba(41, 37, 36, 0.85);
        border: 1px solid rgba(168, 162, 158, 0.2);
        color: #a8a29e;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        z-index: 100;
        backdrop-filter: blur(8px);
      }

      .panel-toggle:hover {
        background: rgba(68, 64, 60, 0.9);
        color: #d6d3d1;
      }

      .panel-toggle svg {
        width: 20px;
        height: 20px;
      }

      /* Camera toggle button */
      .camera-toggle {
        position: fixed;
        bottom: 20px;
        right: 76px;
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: rgba(41, 37, 36, 0.85);
        border: 1px solid rgba(168, 162, 158, 0.2);
        color: #78716c;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        z-index: 100;
        backdrop-filter: blur(8px);
      }

      .camera-toggle:hover {
        background: rgba(68, 64, 60, 0.9);
        color: #a8a29e;
      }

      .camera-toggle.active {
        background: rgba(68, 64, 60, 0.95);
        color: #fafaf9;
        border-color: rgba(214, 211, 209, 0.3);
      }

      .camera-toggle svg {
        width: 18px;
        height: 18px;
      }

      /* Control panel */
      .control-panel {
        position: fixed;
        bottom: 76px;
        right: 20px;
        width: 280px;
        max-height: calc(100vh - 120px);
        background: rgba(28, 25, 23, 0.92);
        border: 1px solid rgba(168, 162, 158, 0.15);
        border-radius: 12px;
        padding: 16px;
        z-index: 99;
        backdrop-filter: blur(12px);
        transform: translateY(10px);
        opacity: 0;
        pointer-events: none;
        transition: all 0.25s ease;
        overflow-y: auto;
      }

      .control-panel.open {
        transform: translateY(0);
        opacity: 1;
        pointer-events: auto;
      }

      .panel-section {
        margin-bottom: 16px;
      }

      .panel-section:last-child {
        margin-bottom: 0;
      }

      .section-title {
        font-size: 10px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: #78716c;
        margin-bottom: 10px;
      }

      .control-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
      }

      .control-row:last-child {
        margin-bottom: 0;
      }

      .control-label {
        font-size: 12px;
        color: #a8a29e;
      }

      .control-value {
        font-size: 11px;
        color: #78716c;
        min-width: 36px;
        text-align: right;
        font-variant-numeric: tabular-nums;
      }

      .slider-container {
        flex: 1;
        margin: 0 10px;
      }

      input[type="range"] {
        width: 100%;
        height: 4px;
        background: rgba(120, 113, 108, 0.3);
        border-radius: 2px;
        -webkit-appearance: none;
        appearance: none;
        cursor: pointer;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 14px;
        height: 14px;
        background: #d6d3d1;
        border-radius: 50%;
        cursor: pointer;
        transition: background 0.15s ease;
      }

      input[type="range"]::-webkit-slider-thumb:hover {
        background: #fafaf9;
      }

      /* Hint overlay */
      .hint {
        position: fixed;
        bottom: 20px;
        left: 20px;
        font-size: 11px;
        color: rgba(168, 162, 158, 0.6);
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .hint.hidden {
        opacity: 0;
      }

      /* Loading state */
      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #78716c;
        font-size: 13px;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>

    <div class="loading" id="loading">Loading...</div>

    <div class="hint" id="hint">
      拖曳調整太陽方向 · 滾輪調整霧氣
    </div>

    <button class="camera-toggle" id="cameraToggle" title="相機移動">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
        <circle cx="12" cy="13" r="4"></circle>
      </svg>
    </button>

    <button class="panel-toggle" id="panelToggle" title="調整參數">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
      </svg>
    </button>

    <div class="control-panel" id="controlPanel">
      <div class="panel-section">
        <div class="section-title">地形</div>
        <div class="control-row">
          <span class="control-label">高度</span>
          <div class="slider-container">
            <input type="range" id="terrainHeight" min="300" max="900" value="600" step="10">
          </div>
          <span class="control-value" id="terrainHeightVal">600</span>
        </div>
        <div class="control-row">
          <span class="control-label">懸崖</span>
          <div class="slider-container">
            <input type="range" id="cliffHeight" min="0" max="200" value="90" step="5">
          </div>
          <span class="control-value" id="cliffHeightVal">90</span>
        </div>
      </div>

      <div class="panel-section">
        <div class="section-title">雲層</div>
        <div class="control-row">
          <span class="control-label">雲量</span>
          <div class="slider-container">
            <input type="range" id="cloudDensity" min="100" max="800" value="400" step="10">
          </div>
          <span class="control-value" id="cloudDensityVal">400</span>
        </div>
        <div class="control-row">
          <span class="control-label">大小</span>
          <div class="slider-container">
            <input type="range" id="cloudScale" min="0.0005" max="0.004" value="0.0015" step="0.0001">
          </div>
          <span class="control-value" id="cloudScaleVal">1.5</span>
        </div>
      </div>

      <div class="panel-section">
        <div class="section-title">樹木</div>
        <div class="control-row">
          <span class="control-label">高度</span>
          <div class="slider-container">
            <input type="range" id="treeHeight" min="2" max="10" value="4.8" step="0.2">
          </div>
          <span class="control-value" id="treeHeightVal">4.8</span>
        </div>
        <div class="control-row">
          <span class="control-label">密度</span>
          <div class="slider-container">
            <input type="range" id="treeDensity" min="1" max="5" value="2" step="0.2">
          </div>
          <span class="control-value" id="treeDensityVal">2.0</span>
        </div>
      </div>

      <div class="panel-section">
        <div class="section-title">色彩</div>
        <div class="control-row">
          <span class="control-label">大氣</span>
          <div class="slider-container">
            <input type="range" id="atmosphereTint" min="0" max="1" value="0.5" step="0.05">
          </div>
          <span class="control-value" id="atmosphereTintVal">0.50</span>
        </div>
        <div class="control-row">
          <span class="control-label">色溫</span>
          <div class="slider-container">
            <input type="range" id="sunWarmth" min="0" max="1" value="0.5" step="0.05">
          </div>
          <span class="control-value" id="sunWarmthVal">0.50</span>
        </div>
      </div>
    </div>

    <script>
      import * as THREE from 'three'

      // ============================================
      // Shader Code (converted from Shadertoy)
      // ============================================

      const bufferVertexShader = `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `

      const bufferFragmentShader = `
        precision highp float;

        uniform vec2 iResolution;
        uniform float iTime;
        uniform int iFrame;
        uniform sampler2D iChannel0;

        // Adjustable parameters
        uniform float uSunTheta;
        uniform float uSunPhi;
        uniform float uFogDensity;
        uniform float uTerrainHeight;
        uniform float uCliffHeight;
        uniform float uCloudDensity;
        uniform float uCloudScale;
        uniform float uTreeHeight;
        uniform float uTreeDensity;
        uniform float uAtmosphereTint;
        uniform float uSunWarmth;
        uniform float uCameraAuto;

        varying vec2 vUv;

        #define ZERO 0
        #define LOWQUALITY

        // ========== Utilities ==========
        float sdEllipsoidY(in vec3 p, in vec2 r) {
          float k0 = length(p / r.xyx);
          float k1 = length(p / (r.xyx * r.xyx));
          return k0 * (k0 - 1.0) / k1;
        }

        vec2 smoothstepd(float a, float b, float x) {
          if (x < a) return vec2(0.0, 0.0);
          if (x > b) return vec2(1.0, 0.0);
          float ir = 1.0 / (b - a);
          x = (x - a) * ir;
          return vec2(x * x * (3.0 - 2.0 * x), 6.0 * x * (1.0 - x) * ir);
        }

        mat3 setCamera(in vec3 ro, in vec3 ta, float cr) {
          vec3 cw = normalize(ta - ro);
          vec3 cp = vec3(sin(cr), cos(cr), 0.0);
          vec3 cu = normalize(cross(cw, cp));
          vec3 cv = normalize(cross(cu, cw));
          return mat3(cu, cv, cw);
        }

        // ========== Hashes ==========
        float hash1v(vec2 p) {
          p = 50.0 * fract(p * 0.3183099);
          return fract(p.x * p.y * (p.x + p.y));
        }

        float hash1f(float n) {
          return fract(n * 17.0 * fract(n * 0.3183099));
        }

        vec2 hash2(vec2 p) {
          const vec2 k = vec2(0.3183099, 0.3678794);
          float n = 111.0 * p.x + 113.0 * p.y;
          return fract(n * fract(k * n));
        }

        // ========== Noise ==========
        vec4 noised3(in vec3 x) {
          vec3 p = floor(x);
          vec3 w = fract(x);
          vec3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);
          vec3 du = 30.0 * w * w * (w * (w - 2.0) + 1.0);

          float n = p.x + 317.0 * p.y + 157.0 * p.z;

          float a = hash1f(n + 0.0);
          float b = hash1f(n + 1.0);
          float c = hash1f(n + 317.0);
          float d = hash1f(n + 318.0);
          float e = hash1f(n + 157.0);
          float f = hash1f(n + 158.0);
          float g = hash1f(n + 474.0);
          float h = hash1f(n + 475.0);

          float k0 = a;
          float k1 = b - a;
          float k2 = c - a;
          float k3 = e - a;
          float k4 = a - b - c + d;
          float k5 = a - c - e + g;
          float k6 = a - b - e + f;
          float k7 = -a + b + c - d + e - f - g + h;

          return vec4(
            -1.0 + 2.0 * (k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z + k6 * u.z * u.x + k7 * u.x * u.y * u.z),
            2.0 * du * vec3(
              k1 + k4 * u.y + k6 * u.z + k7 * u.y * u.z,
              k2 + k5 * u.z + k4 * u.x + k7 * u.z * u.x,
              k3 + k6 * u.x + k5 * u.y + k7 * u.x * u.y
            )
          );
        }

        float noise3(in vec3 x) {
          vec3 p = floor(x);
          vec3 w = fract(x);
          vec3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);

          float n = p.x + 317.0 * p.y + 157.0 * p.z;

          float a = hash1f(n + 0.0);
          float b = hash1f(n + 1.0);
          float c = hash1f(n + 317.0);
          float d = hash1f(n + 318.0);
          float e = hash1f(n + 157.0);
          float f = hash1f(n + 158.0);
          float g = hash1f(n + 474.0);
          float h = hash1f(n + 475.0);

          float k0 = a;
          float k1 = b - a;
          float k2 = c - a;
          float k3 = e - a;
          float k4 = a - b - c + d;
          float k5 = a - c - e + g;
          float k6 = a - b - e + f;
          float k7 = -a + b + c - d + e - f - g + h;

          return -1.0 + 2.0 * (k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z + k6 * u.z * u.x + k7 * u.x * u.y * u.z);
        }

        vec3 noised2(in vec2 x) {
          vec2 p = floor(x);
          vec2 w = fract(x);
          vec2 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);
          vec2 du = 30.0 * w * w * (w * (w - 2.0) + 1.0);

          float a = hash1v(p + vec2(0, 0));
          float b = hash1v(p + vec2(1, 0));
          float c = hash1v(p + vec2(0, 1));
          float d = hash1v(p + vec2(1, 1));

          float k0 = a;
          float k1 = b - a;
          float k2 = c - a;
          float k4 = a - b - c + d;

          return vec3(
            -1.0 + 2.0 * (k0 + k1 * u.x + k2 * u.y + k4 * u.x * u.y),
            2.0 * du * vec2(k1 + k4 * u.y, k2 + k4 * u.x)
          );
        }

        float noise2(in vec2 x) {
          vec2 p = floor(x);
          vec2 w = fract(x);
          vec2 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);

          float a = hash1v(p + vec2(0, 0));
          float b = hash1v(p + vec2(1, 0));
          float c = hash1v(p + vec2(0, 1));
          float d = hash1v(p + vec2(1, 1));

          return -1.0 + 2.0 * (a + (b - a) * u.x + (c - a) * u.y + (a - b - c + d) * u.x * u.y);
        }

        // ========== FBM ==========
        const mat3 m3 = mat3(0.00, 0.80, 0.60, -0.80, 0.36, -0.48, -0.60, -0.48, 0.64);
        const mat3 m3i = mat3(0.00, -0.80, -0.60, 0.80, 0.36, -0.48, 0.60, -0.48, 0.64);
        const mat2 m2 = mat2(0.80, 0.60, -0.60, 0.80);
        const mat2 m2i = mat2(0.80, -0.60, 0.60, 0.80);

        float fbm_4_2d(in vec2 x) {
          float f = 1.9;
          float s = 0.55;
          float a = 0.0;
          float b = 0.5;
          for (int i = 0; i < 4; i++) {
            float n = noise2(x);
            a += b * n;
            b *= s;
            x = f * m2 * x;
          }
          return a;
        }

        float fbm_4_3d(in vec3 x) {
          float f = 2.0;
          float s = 0.5;
          float a = 0.0;
          float b = 0.5;
          for (int i = 0; i < 4; i++) {
            float n = noise3(x);
            a += b * n;
            b *= s;
            x = f * m3 * x;
          }
          return a;
        }

        vec4 fbmd_7(in vec3 x) {
          float f = 1.92;
          float s = 0.5;
          float a = 0.0;
          float b = 0.5;
          vec3 d = vec3(0.0);
          mat3 m = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
          for (int i = 0; i < 7; i++) {
            vec4 n = noised3(x);
            a += b * n.x;
            d += b * m * n.yzw;
            b *= s;
            x = f * m3 * x;
            m = f * m3i * m;
          }
          return vec4(a, d);
        }

        vec4 fbmd_8(in vec3 x) {
          float f = 2.0;
          float s = 0.65;
          float a = 0.0;
          float b = 0.5;
          vec3 d = vec3(0.0);
          mat3 m = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
          for (int i = 0; i < 8; i++) {
            vec4 n = noised3(x);
            a += b * n.x;
            if (i < 4) d += b * m * n.yzw;
            b *= s;
            x = f * m3 * x;
            m = f * m3i * m;
          }
          return vec4(a, d);
        }

        float fbm_9(in vec2 x) {
          float f = 1.9;
          float s = 0.55;
          float a = 0.0;
          float b = 0.5;
          for (int i = 0; i < 9; i++) {
            float n = noise2(x);
            a += b * n;
            b *= s;
            x = f * m2 * x;
          }
          return a;
        }

        vec3 fbmd_9(in vec2 x) {
          float f = 1.9;
          float s = 0.55;
          float a = 0.0;
          float b = 0.5;
          vec2 d = vec2(0.0);
          mat2 m = mat2(1.0, 0.0, 0.0, 1.0);
          for (int i = 0; i < 9; i++) {
            vec3 n = noised2(x);
            a += b * n.x;
            d += b * m * n.yz;
            b *= s;
            x = f * m2 * x;
            m = f * m2i * m;
          }
          return vec3(a, d);
        }

        // ========== Scene Specifics ==========
        vec3 kSunDir;
        float kMaxTreeHeight;
        const float kMaxHeight = 840.0;

        vec3 fog(in vec3 col, float t) {
          float density = uFogDensity;
          vec3 fogColor = mix(vec3(0.55, 0.55, 0.58), vec3(0.45, 0.50, 0.65), uAtmosphereTint);
          vec3 ext = exp2(-t * density * vec3(1.0, 1.5, 4.0));
          return col * ext + (1.0 - ext) * fogColor;
        }

        // ========== Clouds ==========
        vec4 cloudsFbm(in vec3 pos) {
          return fbmd_8(pos * uCloudScale + vec3(2.0, 1.1, 1.0) + 0.07 * vec3(iTime, 0.5 * iTime, -0.15 * iTime));
        }

        vec4 cloudsMap(in vec3 pos, out float nnd) {
          float d = abs(pos.y - 900.0) - 40.0;
          vec3 gra = vec3(0.0, sign(pos.y - 900.0), 0.0);

          vec4 n = cloudsFbm(pos);
          d += uCloudDensity * n.x * (0.7 + 0.3 * gra.y);

          if (d > 0.0) return vec4(-d, 0.0, 0.0, 0.0);

          nnd = -d;
          d = min(-d / 100.0, 0.25);

          return vec4(d, gra);
        }

        float cloudsShadowFlat(in vec3 ro, in vec3 rd) {
          float t = (900.0 - ro.y) / rd.y;
          if (t < 0.0) return 1.0;
          vec3 pos = ro + rd * t;
          return cloudsFbm(pos).x;
        }

        float terrainShadow(in vec3 ro, in vec3 rd, in float mint);

        vec4 renderClouds(in vec3 ro, in vec3 rd, float tmin, float tmax, inout float resT, in vec2 px) {
          vec4 sum = vec4(0.0);

          float tl = (600.0 - ro.y) / rd.y;
          float th = (1200.0 - ro.y) / rd.y;
          if (tl > 0.0) tmin = max(tmin, tl); else return sum;
          if (th > 0.0) tmax = min(tmax, th);

          float t = tmin;
          float lastT = -1.0;
          float thickness = 0.0;

          for (int i = 0; i < 128; i++) {
            vec3 pos = ro + t * rd;
            float nnd;
            vec4 denGra = cloudsMap(pos, nnd);
            float den = denGra.x;
            float dt = max(0.2, 0.011 * t);

            if (den > 0.001) {
              float kk;
              cloudsMap(pos + kSunDir * 70.0, kk);
              float sha = 1.0 - smoothstep(-200.0, 200.0, kk);
              sha *= 1.5;

              vec3 nor = normalize(denGra.yzw);
              float dif = clamp(0.4 + 0.6 * dot(nor, kSunDir), 0.0, 1.0) * sha;
              float fre = clamp(1.0 + dot(nor, rd), 0.0, 1.0) * sha;
              float occ = 0.2 + 0.7 * max(1.0 - kk / 200.0, 0.0) + 0.1 * (1.0 - den);

              vec3 lin = vec3(0.0);
              lin += vec3(0.70, 0.80, 1.00) * 1.0 * (0.5 + 0.5 * nor.y) * occ;
              lin += vec3(0.10, 0.40, 0.20) * 1.0 * (0.5 - 0.5 * nor.y) * occ;

              vec3 sunColor = mix(vec3(1.0, 0.9, 0.8), vec3(1.0, 0.95, 0.85), uSunWarmth);
              lin += sunColor * 3.0 * dif * occ + 0.1;

              vec3 col = vec3(0.8, 0.8, 0.8) * 0.45;
              col *= lin;
              col = fog(col, t);

              float alp = clamp(den * 0.5 * 0.125 * dt, 0.0, 1.0);
              col.rgb *= alp;
              sum = sum + vec4(col, alp) * (1.0 - sum.a);

              thickness += dt * den;
              if (lastT < 0.0) lastT = t;
            } else {
              dt = abs(den) + 0.2;
            }

            t += dt;
            if (sum.a > 0.995 || t > tmax) break;
          }

          if (lastT > 0.0) resT = min(resT, lastT);

          vec3 glareColor = mix(vec3(1.0, 0.5, 0.3), vec3(1.0, 0.6, 0.4), uSunWarmth);
          sum.xyz += max(0.0, 1.0 - 0.0125 * thickness) * glareColor * 0.3 * pow(clamp(dot(kSunDir, rd), 0.0, 1.0), 32.0);

          return clamp(sum, 0.0, 1.0);
        }

        // ========== Terrain ==========
        vec2 terrainMap(in vec2 p) {
          float e = fbm_9(p / 2000.0 + vec2(1.0, -2.0));
          float a = 1.0 - smoothstep(0.12, 0.13, abs(e + 0.12));
          e = uTerrainHeight * e + uTerrainHeight;

          e += uCliffHeight * smoothstep(552.0, 594.0, e);

          return vec2(e, a);
        }

        vec4 terrainMapD(in vec2 p) {
          vec3 e = fbmd_9(p / 2000.0 + vec2(1.0, -2.0));
          e.x = uTerrainHeight * e.x + uTerrainHeight;
          e.yz = uTerrainHeight * e.yz;

          vec2 c = smoothstepd(550.0, 600.0, e.x);
          e.x = e.x + uCliffHeight * c.x;
          e.yz = e.yz + uCliffHeight * c.y * e.yz;

          e.yz /= 2000.0;
          return vec4(e.x, normalize(vec3(-e.y, 1.0, -e.z)));
        }

        vec3 terrainNormal(in vec2 pos) {
          return terrainMapD(pos).yzw;
        }

        float terrainShadow(in vec3 ro, in vec3 rd, in float mint) {
          float res = 1.0;
          float t = mint;
          for (int i = 0; i < 32; i++) {
            vec3 pos = ro + t * rd;
            vec2 env = terrainMap(pos.xz);
            float hei = pos.y - env.x;
            res = min(res, 32.0 * hei / t);
            if (res < 0.0001 || pos.y > kMaxHeight) break;
            t += clamp(hei, 2.0 + t * 0.1, 100.0);
          }
          return clamp(res, 0.0, 1.0);
        }

        vec2 raymarchTerrain(in vec3 ro, in vec3 rd, float tmin, float tmax) {
          float tp = (kMaxHeight + kMaxTreeHeight - ro.y) / rd.y;
          if (tp > 0.0) tmax = min(tmax, tp);

          float dis, th;
          float t2 = -1.0;
          float t = tmin;
          float ot = t;
          float odis = 0.0;
          float odis2 = 0.0;

          for (int i = 0; i < 400; i++) {
            th = 0.001 * t;
            vec3 pos = ro + t * rd;
            vec2 env = terrainMap(pos.xz);
            float hei = env.x;

            float dis2 = pos.y - (hei + kMaxTreeHeight * 1.1);
            if (dis2 < th) {
              if (t2 < 0.0) {
                t2 = ot + (th - odis2) * (t - ot) / (dis2 - odis2);
              }
            }
            odis2 = dis2;

            dis = pos.y - hei;
            if (dis < th) break;

            ot = t;
            odis = dis;
            t += dis * 0.8 * (1.0 - 0.75 * env.y);
            if (t > tmax) break;
          }

          if (t > tmax) t = -1.0;
          else t = ot + (th - odis) * (t - ot) / (dis - odis);

          return vec2(t, t2);
        }

        // ========== Trees ==========
        float treesMap(in vec3 p, in float rt, out float oHei, out float oMat, out float oDis) {
          oHei = 1.0;
          oDis = 0.0;
          oMat = 0.0;

          float base = terrainMap(p.xz).x;
          float bb = fbm_4_2d(p.xz * 0.075);

          float d = 20.0;
          vec2 n = floor(p.xz / uTreeDensity);
          vec2 f = fract(p.xz / uTreeDensity);

          for (int j = 0; j <= 1; j++)
          for (int i = 0; i <= 1; i++) {
            vec2 g = vec2(float(i), float(j)) - step(f, vec2(0.5));
            vec2 o = hash2(n + g);
            vec2 v = hash2(n + g + vec2(13.1, 71.7));
            vec2 r = g - f + o;

            float height = kMaxTreeHeight * (0.4 + 0.8 * v.x);
            float width = 0.5 + 0.2 * v.x + 0.3 * v.y;

            if (bb < 0.0) width *= 0.5; else height *= 0.7;

            vec3 q = vec3(r.x, p.y - base - height * 0.5, r.y);
            float k = sdEllipsoidY(q, vec2(width, 0.5 * height));

            if (k < d) {
              d = k;
              oMat = 0.5 * hash1v(n + g + 111.0);
              if (bb > 0.0) oMat += 0.5;
              oHei = (p.y - base) / height;
              oHei *= 0.5 + 0.5 * length(q) / width;
            }
          }

          if (rt < 1200.0) {
            p.y -= 600.0;
            float s = fbm_4_3d(p * 3.0);
            s = s * s;
            float att = 1.0 - smoothstep(100.0, 1200.0, rt);
            d += 4.0 * s * att;
            oDis = s * att;
          }

          return d;
        }

        float treesShadow(in vec3 ro, in vec3 rd) {
          float res = 1.0;
          float t = 0.02;
          for (int i = 0; i < 64; i++) {
            float kk1, kk2, kk3;
            vec3 pos = ro + rd * t;
            float h = treesMap(pos, t, kk1, kk2, kk3);
            res = min(res, 32.0 * h / t);
            t += h;
            if (res < 0.001 || t > 50.0 || pos.y > kMaxHeight + kMaxTreeHeight) break;
          }
          return clamp(res, 0.0, 1.0);
        }

        vec3 treesNormal(in vec3 pos, in float t) {
          float kk1, kk2, kk3;
          vec3 n = vec3(0.0);
          for (int i = 0; i < 4; i++) {
            vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);
            n += e * treesMap(pos + 0.005 * e, t, kk1, kk2, kk3);
          }
          return normalize(n);
        }

        // ========== Sky ==========
        vec3 renderSky(in vec3 ro, in vec3 rd) {
          vec3 skyColor = mix(vec3(0.42, 0.62, 1.1), vec3(0.35, 0.55, 1.0), uAtmosphereTint);
          vec3 col = skyColor - rd.y * 0.4;

          float t = (2500.0 - ro.y) / rd.y;
          if (t > 0.0) {
            vec2 uv = (ro + t * rd).xz;
            float cl = fbm_9(uv * 0.00104);
            float dl = smoothstep(-0.2, 0.6, cl);
            col = mix(col, vec3(1.0), 0.12 * dl);
          }

          float sun = clamp(dot(kSunDir, rd), 0.0, 1.0);
          vec3 glareColor = mix(vec3(1.0, 0.5, 0.2), vec3(1.0, 0.6, 0.3), uSunWarmth);
          col += 0.2 * glareColor * pow(sun, 32.0);

          return col;
        }

        // ========== Main ==========
        void main() {
          vec2 fragCoord = vUv * iResolution;
          vec2 o = hash2(vec2(float(iFrame), 1.0)) - 0.5;
          vec2 p = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;

          // Calculate sun direction from spherical coordinates
          float theta = uSunTheta;
          float phi = uSunPhi;
          kSunDir = normalize(vec3(
            sin(theta) * cos(phi),
            cos(theta),
            sin(theta) * sin(phi)
          ));

          kMaxTreeHeight = uTreeHeight;

          // Camera
          float time = iTime;
          vec3 ro = vec3(0.0, 401.5, 6.0);
          vec3 ta = vec3(0.0, 403.5, -90.0 + ro.z);

          // Auto camera movement (when enabled)
          float camMove = 80.0 * sin(0.01 * time) * uCameraAuto;
          ro.x -= camMove;
          ta.x -= camMove * 1.075;

          mat3 ca = setCamera(ro, ta, 0.0);
          vec3 rd = ca * normalize(vec3(p, 1.5));

          float resT = 2000.0;

          // Sky
          vec3 col = renderSky(ro, rd);

          // Terrain and trees
          {
            const float tmax = 2000.0;
            int obj = 0;
            vec2 t = raymarchTerrain(ro, rd, 15.0, tmax);
            if (t.x > 0.0) {
              resT = t.x;
              obj = 1;
            }

            float hei, mid, displa;

            if (t.y > 0.0) {
              float tf = t.y;
              float tfMax = (t.x > 0.0) ? t.x : tmax;
              for (int i = 0; i < 64; i++) {
                vec3 pos = ro + tf * rd;
                float dis = treesMap(pos, tf, hei, mid, displa);
                if (dis < (0.000125 * tf)) break;
                tf += dis;
                if (tf > tfMax) break;
              }
              if (tf < tfMax) {
                resT = tf;
                obj = 2;
              }
            }

            if (obj > 0) {
              vec3 pos = ro + resT * rd;
              vec3 epos = pos + vec3(0.0, 4.8, 0.0);

              float sha1 = terrainShadow(pos + vec3(0, 0.02, 0), kSunDir, 0.02);
              sha1 *= smoothstep(-0.325, -0.075, cloudsShadowFlat(epos, kSunDir));

              vec3 tnor = terrainNormal(pos.xz);
              vec3 nor;
              vec3 speC = vec3(1.0);

              if (obj == 1) {
                nor = normalize(tnor + 0.8 * (1.0 - abs(tnor.y)) * 0.8 * fbmd_7((pos - vec3(0, 600, 0)) * 0.15 * vec3(1.0, 0.2, 1.0)).yzw);

                col = vec3(0.18, 0.12, 0.10) * 0.85;
                col = 1.0 * mix(col, vec3(0.1, 0.1, 0.0) * 0.2, smoothstep(0.7, 0.9, nor.y));

                float dif = clamp(dot(nor, kSunDir), 0.0, 1.0);
                dif *= sha1;

                float bac = clamp(dot(normalize(vec3(-kSunDir.x, 0.0, -kSunDir.z)), nor), 0.0, 1.0);
                float foc = clamp((pos.y / 2.0 - 180.0) / 130.0, 0.0, 1.0);
                float dom = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);

                vec3 lin = 1.0 * 0.2 * mix(0.1 * vec3(0.1, 0.2, 0.1), vec3(0.7, 0.9, 1.5) * 3.0, dom) * foc;

                vec3 sunLight = mix(vec3(1.0, 0.85, 0.7), vec3(1.0, 0.9, 0.8), uSunWarmth);
                lin += 1.0 * 8.5 * sunLight * dif;
                lin += 1.0 * 0.27 * vec3(1.1, 1.0, 0.9) * bac * foc;

                speC = vec3(4.0) * dif * smoothstep(20.0, 0.0, abs(pos.y / 2.0 - 310.0) - 20.0);

                col *= lin;
              } else {
                vec3 gnor = treesNormal(pos, resT);
                nor = normalize(gnor + 2.0 * tnor);

                vec3 ref = reflect(rd, nor);
                float occ = clamp(hei, 0.0, 1.0) * pow(1.0 - 2.0 * displa, 3.0);
                float dif = clamp(0.1 + 0.9 * dot(nor, kSunDir), 0.0, 1.0);
                dif *= sha1;

                if (dif > 0.0001) {
                  float a = clamp(0.5 + 0.5 * dot(tnor, kSunDir), 0.0, 1.0);
                  a = a * a;
                  a *= occ;
                  a *= 0.6;
                  a *= smoothstep(60.0, 200.0, resT);
                  float sha2 = treesShadow(pos + kSunDir * 0.1, kSunDir);
                  dif *= a + (1.0 - a) * sha2;
                }

                float dom = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);
                float bac = clamp(0.5 + 0.5 * dot(normalize(vec3(-kSunDir.x, 0.0, -kSunDir.z)), nor), 0.0, 1.0);
                float fre = clamp(1.0 + dot(nor, rd), 0.0, 1.0);

                vec3 sunLight = mix(vec3(1.15, 0.95, 0.65), vec3(1.2, 1.0, 0.7), uSunWarmth);
                vec3 lin = 12.0 * sunLight * dif * occ * (2.5 - 1.5 * smoothstep(0.0, 120.0, resT));
                lin += 0.55 * mix(0.1 * vec3(0.1, 0.2, 0.0), vec3(0.6, 1.0, 1.0), dom * occ);
                lin += 0.07 * vec3(1.0, 1.0, 0.9) * bac * occ;
                lin += 1.10 * vec3(0.9, 1.0, 0.8) * pow(fre, 5.0) * occ * (1.0 - smoothstep(100.0, 200.0, resT));

                speC = dif * vec3(1.0, 1.1, 1.5) * 1.2;

                float brownAreas = fbm_4_2d(pos.zx * 0.015);
                col = vec3(0.2, 0.2, 0.05);
                col = mix(col, vec3(0.32, 0.2, 0.05), smoothstep(0.2, 0.9, fract(2.0 * mid)));
                col *= (mid < 0.5) ? 0.65 + 0.35 * smoothstep(300.0, 600.0, resT) * smoothstep(700.0, 500.0, pos.y) : 1.0;
                col = mix(col, vec3(0.25, 0.16, 0.01) * 0.825, 0.7 * smoothstep(0.1, 0.3, brownAreas) * smoothstep(0.5, 0.8, tnor.y));
                col *= 1.0 - 0.5 * smoothstep(400.0, 700.0, pos.y);
                col *= lin;
              }

              vec3 ref = reflect(rd, nor);
              float fre = clamp(1.0 + dot(nor, rd), 0.0, 1.0);
              float spe = 3.0 * pow(clamp(dot(ref, kSunDir), 0.0, 1.0), 9.0) * (0.05 + 0.95 * pow(fre, 5.0));
              col += spe * speC;

              col = fog(col, resT);
            }
          }

          float isCloud = 0.0;

          // Clouds
          {
            vec4 res = renderClouds(ro, rd, 0.0, resT, resT, fragCoord);
            col = col * (1.0 - res.w) + res.xyz;
            isCloud = res.w;
          }

          // Sun glare
          float sun = clamp(dot(kSunDir, rd), 0.0, 1.0);
          vec3 glareColor = mix(vec3(0.7, 0.35, 0.15), vec3(0.8, 0.4, 0.2), uSunWarmth);
          col += 0.25 * glareColor * pow(sun, 4.0);

          // Gamma
          col = pow(clamp(col * 1.1 - 0.02, 0.0, 1.0), vec3(0.4545));

          // Contrast
          col = col * col * (3.0 - 2.0 * col);

          // Color grade
          col = pow(col, vec3(1.0, 0.92, 1.0));
          col *= vec3(1.02, 0.99, 0.9);
          col.z = col.z + 0.1;

          // Simple temporal accumulation
          vec3 ocol = texture2D(iChannel0, vUv).xyz;
          if (iFrame == 0) ocol = col;
          col = mix(ocol, col, 0.15 + 0.7 * isCloud);

          gl_FragColor = vec4(col, 1.0);
        }
      `

      const imageVertexShader = `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `

      const imageFragmentShader = `
        precision highp float;
        uniform sampler2D iChannel0;
        uniform vec2 iResolution;
        varying vec2 vUv;

        void main() {
          vec2 p = vUv;
          vec3 col = texture2D(iChannel0, p).xyz;

          // Vignette
          col *= 0.5 + 0.5 * pow(16.0 * p.x * p.y * (1.0 - p.x) * (1.0 - p.y), 0.05);

          gl_FragColor = vec4(col, 1.0);
        }
      `

      // ============================================
      // Application
      // ============================================

      class LandscapeApp {
        canvas: HTMLCanvasElement
        renderer: THREE.WebGLRenderer
        scene: THREE.Scene
        camera: THREE.OrthographicCamera
        postScene: THREE.Scene
        postCamera: THREE.OrthographicCamera
        params: Record<string, number>
        frame: number
        startTime: number
        isDragging: boolean
        lastMouse: { x: number; y: number }
        hintTimeout: ReturnType<typeof setTimeout> | null
        cameraAutoEnabled: boolean
        rtA!: THREE.WebGLRenderTarget
        rtB!: THREE.WebGLRenderTarget
        bufferMaterial!: THREE.ShaderMaterial
        bufferMesh!: THREE.Mesh
        postMaterial!: THREE.ShaderMaterial
        postMesh!: THREE.Mesh

        constructor() {
          this.canvas = document.getElementById('canvas') as HTMLCanvasElement
          this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: false })
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5))

          this.scene = new THREE.Scene()
          this.camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0.1, 10)
          this.camera.position.z = 1

          this.postScene = new THREE.Scene()
          this.postCamera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0.1, 10)
          this.postCamera.position.z = 1

          this.frame = 0
          this.startTime = Date.now()
          this.isDragging = false
          this.lastMouse = { x: 0, y: 0 }
          this.hintTimeout = null
          this.cameraAutoEnabled = false

          // Parameters
          this.params = {
            sunTheta: 1.2,
            sunPhi: 2.4,
            fogDensity: 0.00025,
            terrainHeight: 600,
            cliffHeight: 90,
            cloudDensity: 400,
            cloudScale: 0.0015,
            treeHeight: 4.8,
            treeDensity: 2.0,
            atmosphereTint: 0.5,
            sunWarmth: 0.5,
            cameraAuto: 0.0
          }

          this.init()
        }

        init() {
          this.resize()

          // Create render targets for ping-pong
          const size = this.renderer.getSize(new THREE.Vector2())
          const rtOptions = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            type: THREE.FloatType
          }
          this.rtA = new THREE.WebGLRenderTarget(size.x, size.y, rtOptions)
          this.rtB = new THREE.WebGLRenderTarget(size.x, size.y, rtOptions)

          // Buffer material
          this.bufferMaterial = new THREE.ShaderMaterial({
            vertexShader: bufferVertexShader,
            fragmentShader: bufferFragmentShader,
            uniforms: {
              iResolution: { value: new THREE.Vector2(size.x, size.y) },
              iTime: { value: 0 },
              iFrame: { value: 0 },
              iChannel0: { value: this.rtA.texture },
              uSunTheta: { value: this.params.sunTheta },
              uSunPhi: { value: this.params.sunPhi },
              uFogDensity: { value: this.params.fogDensity },
              uTerrainHeight: { value: this.params.terrainHeight },
              uCliffHeight: { value: this.params.cliffHeight },
              uCloudDensity: { value: this.params.cloudDensity },
              uCloudScale: { value: this.params.cloudScale },
              uTreeHeight: { value: this.params.treeHeight },
              uTreeDensity: { value: this.params.treeDensity },
              uAtmosphereTint: { value: this.params.atmosphereTint },
              uSunWarmth: { value: this.params.sunWarmth },
              uCameraAuto: { value: this.params.cameraAuto }
            }
          })

          const plane = new THREE.PlaneGeometry(1, 1)
          this.bufferMesh = new THREE.Mesh(plane, this.bufferMaterial)
          this.scene.add(this.bufferMesh)

          // Post-processing material
          this.postMaterial = new THREE.ShaderMaterial({
            vertexShader: imageVertexShader,
            fragmentShader: imageFragmentShader,
            uniforms: {
              iChannel0: { value: this.rtB.texture },
              iResolution: { value: new THREE.Vector2(size.x, size.y) }
            }
          })

          this.postMesh = new THREE.Mesh(plane.clone(), this.postMaterial)
          this.postScene.add(this.postMesh)

          // Events
          window.addEventListener('resize', () => this.resize())
          this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e))
          this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e))
          this.canvas.addEventListener('mouseup', () => this.onMouseUp())
          this.canvas.addEventListener('mouseleave', () => this.onMouseUp())
          this.canvas.addEventListener('wheel', (e) => this.onWheel(e), { passive: false })

          // Touch events
          this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e))
          this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e))
          this.canvas.addEventListener('touchend', () => this.onMouseUp())

          this.setupControls()

          const loadingEl = document.getElementById('loading')
          if (loadingEl) loadingEl.style.display = 'none'

          // Hide hint after 5 seconds
          this.hintTimeout = setTimeout(() => {
            document.getElementById('hint')?.classList.add('hidden')
          }, 5000)

          this.animate()
        }

        resize() {
          const width = window.innerWidth
          const height = window.innerHeight
          this.renderer.setSize(width, height)

          if (this.rtA && this.rtB) {
            const size = this.renderer.getSize(new THREE.Vector2())
            this.rtA.setSize(size.x, size.y)
            this.rtB.setSize(size.x, size.y)

            this.bufferMaterial.uniforms.iResolution.value.set(size.x, size.y)
            this.postMaterial.uniforms.iResolution.value.set(size.x, size.y)

            // Reset frame counter on resize
            this.frame = 0
          }
        }

        onMouseDown(e: MouseEvent) {
          this.isDragging = true
          this.lastMouse = { x: e.clientX, y: e.clientY }
          this.canvas.style.cursor = 'grabbing'
        }

        onMouseMove(e: MouseEvent) {
          if (!this.isDragging) return

          const dx = e.clientX - this.lastMouse.x
          const dy = e.clientY - this.lastMouse.y

          // Adjust sun direction
          this.params.sunPhi += dx * 0.005
          this.params.sunTheta = Math.max(0.3, Math.min(1.5, this.params.sunTheta + dy * 0.003))

          this.bufferMaterial.uniforms.uSunPhi.value = this.params.sunPhi
          this.bufferMaterial.uniforms.uSunTheta.value = this.params.sunTheta

          this.lastMouse = { x: e.clientX, y: e.clientY }
          this.frame = 0 // Reset temporal accumulation
        }

        onMouseUp() {
          this.isDragging = false
          this.canvas.style.cursor = 'grab'
        }

        onTouchStart(e: TouchEvent) {
          if (e.touches.length === 1) {
            this.isDragging = true
            this.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY }
          }
        }

        onTouchMove(e: TouchEvent) {
          if (!this.isDragging || e.touches.length !== 1) return
          e.preventDefault()

          const dx = e.touches[0].clientX - this.lastMouse.x
          const dy = e.touches[0].clientY - this.lastMouse.y

          this.params.sunPhi += dx * 0.005
          this.params.sunTheta = Math.max(0.3, Math.min(1.5, this.params.sunTheta + dy * 0.003))

          this.bufferMaterial.uniforms.uSunPhi.value = this.params.sunPhi
          this.bufferMaterial.uniforms.uSunTheta.value = this.params.sunTheta

          this.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY }
          this.frame = 0
        }

        onWheel(e: WheelEvent) {
          e.preventDefault()
          const delta = e.deltaY > 0 ? 1.1 : 0.9
          this.params.fogDensity = Math.max(0.00005, Math.min(0.001, this.params.fogDensity * delta))
          this.bufferMaterial.uniforms.uFogDensity.value = this.params.fogDensity
          this.frame = 0
        }

        setupControls() {
          const panel = document.getElementById('controlPanel')
          const toggle = document.getElementById('panelToggle')
          const cameraToggle = document.getElementById('cameraToggle')

          toggle?.addEventListener('click', () => {
            panel?.classList.toggle('open')
          })

          // Camera auto toggle
          cameraToggle?.addEventListener('click', () => {
            this.cameraAutoEnabled = !this.cameraAutoEnabled
            this.params.cameraAuto = this.cameraAutoEnabled ? 1.0 : 0.0
            this.bufferMaterial.uniforms.uCameraAuto.value = this.params.cameraAuto
            cameraToggle.classList.toggle('active', this.cameraAutoEnabled)
            this.frame = 0
          })

          // Helper to setup slider
          const setupSlider = (id: string, param: string, transform = (v: number) => v, displayTransform = (v: number) => v.toFixed(1)) => {
            const slider = document.getElementById(id) as HTMLInputElement | null
            const valueEl = document.getElementById(id + 'Val')

            slider?.addEventListener('input', () => {
              const numVal = Number.parseFloat(slider.value)
              const value = transform(numVal)
              this.params[param] = value
              this.bufferMaterial.uniforms['u' + param.charAt(0).toUpperCase() + param.slice(1)].value = value
              if (valueEl) valueEl.textContent = displayTransform(numVal)
              this.frame = 0
            })
          }

          setupSlider('terrainHeight', 'terrainHeight', v => v, v => v.toFixed(0))
          setupSlider('cliffHeight', 'cliffHeight', v => v, v => v.toFixed(0))
          setupSlider('cloudDensity', 'cloudDensity', v => v, v => v.toFixed(0))
          setupSlider('cloudScale', 'cloudScale', v => v, v => (v * 1000).toFixed(1))
          setupSlider('treeHeight', 'treeHeight', v => v, v => v.toFixed(1))
          setupSlider('treeDensity', 'treeDensity', v => v, v => v.toFixed(1))
          setupSlider('atmosphereTint', 'atmosphereTint', v => v, v => v.toFixed(2))
          setupSlider('sunWarmth', 'sunWarmth', v => v, v => v.toFixed(2))
        }

        animate = () => {
          requestAnimationFrame(this.animate)

          const elapsed = (Date.now() - this.startTime) / 1000

          // Update uniforms
          this.bufferMaterial.uniforms.iTime.value = elapsed
          this.bufferMaterial.uniforms.iFrame.value = this.frame
          this.bufferMaterial.uniforms.iChannel0.value = this.rtA.texture

          // Render to rtB
          this.renderer.setRenderTarget(this.rtB)
          this.renderer.render(this.scene, this.camera)

          // Post-process to screen
          this.postMaterial.uniforms.iChannel0.value = this.rtB.texture
          this.renderer.setRenderTarget(null)
          this.renderer.render(this.postScene, this.postCamera)

          // Swap buffers
          const temp = this.rtA
          this.rtA = this.rtB
          this.rtB = temp

          this.frame++
        }
      }

      // Initialize
      const app = new LandscapeApp()
    </script>
  </body>
</html>
