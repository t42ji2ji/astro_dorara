---
title: AI 時代，工程師的價值在哪裡？以及開始退化的工程文化
pubDate: 2025-12-30
categories: ["Essays"]
description: "我靠寫程式吃飯，但我已經不太寫程式了。"
slug: ai_era
draft: true
---

## 一個悖論

我靠寫程式吃飯，但我已經不太寫程式了。

這不是自嘲。過去一年，我的 code 幾乎 100% 來自 AI。打開編輯器，開一個對話視窗，描述需求，拿到 code，貼上，調整，完成。效率高得驚人。

但這件事讓我越來越不安。

不是怕被取代，而是我開始懷疑：當「會寫 code」變得毫無門檻，我這五年累積的東西，還剩下什麼？

這篇文章是我這一年的思考整理。關於 AI 如何改變軟體開發，關於什麼正在貶值、什麼反而更值錢，以及我怎麼在這個變化中重新定位。

---

## 快速實現的陷阱

AI 最明顯的價值是讓想法快速變成現實。你腦中有一個畫面，十分鐘後它就出現在螢幕上。第一次經歷這種速度，確實會驚嘆。

但這裡有一個殘酷的邏輯：當一件事能被快速實現，它就很難擁有太高的價值。

想像一棵果樹。越容易摘到的果實，越早被摘完。當每個人都能用 AI 在一天內做出一個 App 雛形，「能做出 App」這件事本身就不再是競爭力。

表面上看，AI 降低了進入門檻。不會寫 code 的人也能做產品了。但實際上，門檻是往上移的。原本不具備開發能力的人，有了進入的門檻。對於有經驗的開發者，生產力都被放大了。以前一個資深工程師一週能做的事，現在可能兩天就完成。如果你沒有更深的累積，你跟專業者的差距不是縮小了，而是被拉得更開。

市場不會因為大家都變快了，就需要更多工程師。市場會用更少的人，做更多的事。

但這不是最讓我焦慮的部分。真正讓我睡不好的，是我發現工程師正在自我退化。

---

## 過度依賴會導致退化

AI 省下的時間，本來應該讓我們有更多餘裕去深入理解程式碼。但現實剛好相反。

我觀察到一個弔詭的現象：有了 AI 之後，很多人對程式碼細節的討論不是變多，而是變少了。

以前 code review 的時候，大家會爭論命名、會討論這個抽象合不合理、會問「為什麼這樣寫」。現在最常聽到的一句話變成：「這是 AI 寫的。」

彷彿這句話就是免死金牌。AI 寫的，所以不用深究。AI 寫的，所以我也不太確定細節。AI 寫的，反正能跑就好。

這很危險。

當你不再逐行讀 code，你就不會發現那些微妙的問題。當你不再思考「為什麼這樣寫」，你的判斷力就開始萎縮。當你習慣性地把責任推給 AI，你其實是在放棄對自己 codebase 的掌控權。

AI 是工具，不是藉口。它讓你更快產出，不代表你可以更少理解。

事實上，正因為產出變快了，你更應該把省下的時間拿來做 AI 做不到的事：深入理解每一個決策背後的原因，建立自己對系統的完整認知。

如果你只是把 AI 當成「不用自己寫 code」的捷徑，那你省下的不是時間，是成長的機會。

我有一個後端專案，需要監控資金池的水位。我問 AI 怎麼做，它建議我用 cron job 定時輪詢。標準解法，教科書等級。

但我沒有採用。

因為我知道這個資金池的每一筆變動，在我們的流程中都是可控的、可追蹤的。我完全不需要輪詢，只要在每次變動時更新狀態就好。這個解法更節能、更精準、更少出錯的可能。

AI 不知道這些。它不知道「這個系統實際上是怎麼運作的」。它只能根據通用的 pattern 給你通用的答案。

這讓我意識到一件事：AI 是一個極強的執行者，但它不知道什麼是「有意義」的。

這個判斷力的缺失，體現在很多地方。

### 過度設計

有一次我讓 AI 幫我寫一個簡單的設定頁面。它回傳的 code 裡有一個 `SettingsRepository`、一個 `SettingsService`、一個 `ISettingsProvider` interface，還有一個 `SettingsServiceImpl`。

我看著這堆東西，心想：這個頁面就是讀一個 JSON 檔。

AI 很喜歡給你「正確」的架構建議。抽 interface、用 design pattern、加一層抽象。這些建議在教科書上都是對的。但你知道這個功能永遠只會有一個實作，你知道這個專案不會長到需要這層抽象，你知道加了這層只是讓未來的維護者多一個要理解的東西。

AI 不知道。它只知道「這樣做比較乾淨」，但它不會判斷這個乾淨有沒有意義。

### 無效註解

這是最明顯的例子。AI 很喜歡加註解，但它的註解長這樣：

```dart
// 取得使用者
final user = getUser();

// 設定名稱
user.name = name;

// 回傳使用者
return user;
```

每一行註解都只是把 code 翻譯成中文，完全沒有提供額外資訊。真正有價值的註解應該說明「為什麼」。為什麼這邊要這樣做、有什麼特殊考量、有什麼坑要注意。

但 AI 不知道什麼註解是有用的。它只知道「有註解比較好」。

### 無效測試

同樣的問題出現在測試。AI 寫的測試常常在測這些東西：

- Getter 和 setter 能不能正常運作（一定可以）
- Happy path 能不能跑過（最基本的情況）
- 驗證它自己剛寫的 code 能不能執行（同義反覆）

但真正有價值的測試是什麼？是邊界條件、是錯誤處理、是那些「正常使用不會遇到，但一旦遇到就會炸」的情況。這些 AI 不會主動想到，因為它不知道什麼情況真的會出事。

### 程式碼的品味

這是更微妙的東西。

AI 寫的 code 常常「能跑」，但你看了就覺得不對。檔案過於肥大、沒有遵守單一職責、一個 Widget 做太多事情。AI 傾向於把所有東西塞在一起「解決問題」，但它不會主動去想這段 code 三個月後還能不能維護。

品味是什麼？品味是你看到一段 code，不用跑就知道它會出問題。品味是你知道什麼時候該拆、什麼時候不該拆、什麼時候該加註解、什麼時候不該加。

這種判斷力來自於你過去寫過的無數行 code、重構過的無數次架構、debug 過的無數個深夜。AI 沒有這些經歷，所以它只能給你「形式上正確」的東西，而不是「真正有用」的東西。

說到底，真正的工程判斷來自於你對現實世界的理解。這個資料從哪裡來、會怎麼變、誰會去動它、什麼情況下會出錯。這些事情，只有在場的人才知道。

那麼，知道了這些限制之後，我們該怎麼跟 AI 協作？

---

## 我的協作方式

理解 AI 的能力邊界，不是為了抗拒它，而是為了真正發揮它的價值。

以下是我這一年摸索出來的方法。

### 什麼時候放手讓 AI 去做

先說什麼時候我會直接讓 AI 自由發揮，不管太多。

第一種情況是測試和驗證。我想確認某個 library 能不能用、某個 API 的行為是什麼、某個架構可不可行。這時候我只需要一個「能跑」的東西，不需要完美。AI 五分鐘生出來的 prototype，比我花兩小時刻的還有價值，因為它讓我更快知道這條路行不行得通。

第二種是快速上手一個新領域。我不熟 Kubernetes，但我需要 deploy 一個服務。我不會先去讀三天文件，我會直接跟 AI 說：「幫我寫一個最簡單的 deployment yaml，然後解釋每個欄位在幹嘛。」從一個能跑的範例開始，邊改邊學，效率比從零開始高太多。

第三種是我想被 surprise。有時候我會故意不給太多限制，就是想看看 AI 會怎麼解這個問題。它常常會給出我沒想過的方向。不一定會用，但會打開我的思路。

這些情況的共通點是：結果不會直接進 production。我可以接受它不完美，因為目的本來就不是完美，而是探索、學習、或者激發靈感。

但如果是要進 codebase 的東西，那就是另一回事了。

### 給足 Context

AI 的盲點，其實大部分可以用「context 不足」來解釋。 它不知道你的系統怎麼運作、不知道這個功能的使用情境、不知道你的 codebase 有什麼現有的 pattern。所以它只能給你通用答案。

這意味著：你給的 context 越完整，AI 的產出品質就越高。 我現在跟 AI 協作，會把相關的 code 一起貼給它。不只是「幫我寫一個 function」，而是「這是我現有的 Repository，這是我的 Model，我需要一個新的 method 來處理 X 情況」。

### 拆解，然後順序執行

我不會讓 AI 一次做一個完整的 feature。幾乎每次這樣做，結果都是整個爛掉。改動太多、範圍太大、沒辦法一次 review 這麼多東西。最後只能 revert，重新來過。

我的做法是把任務拆成明確的步驟，一步一步執行。

以 Clean Architecture 為例，如果我要做一個新功能：

1. 先定義 Data Model。欄位有哪些、型別是什麼、跟 API 的對應關係
2. 等 Model 完成後，再做 Repository。怎麼從 API 拿資料、怎麼轉換
3. 最後做 Service 或 UseCase。業務邏輯怎麼組合這些資料

每一步都有明確的輸入和輸出，每一步完成後我都會 review，確認跟我想的一致，再進行下一步。

這樣做的好處是：我保留了「設計」的控制權，AI 只負責「施工」。藍圖是我畫的，AI 幫我把磚砌上去。

### 建立自己的工作流

幾年下來，我建立了自己的專案 scaffold。它包含：

- Splash screen 和 App icon 的快速替換腳本
- Bundle ID 的自動配置
- 完整的 Theme 系統
- i18n 國際化架構
- 我常用的動畫 library
- 以及最重要的，我的程式架構骨架

這個 scaffold 不是一次做完的，而是每做一個專案就迭代一次。我做過超過五個 App，每一個都讓這個 scaffold 變得更完整、更順手。

有了這個 scaffold，我開新專案大概可以省下 20 分鐘的初始設定。但這只是開始。真正省下的，是我理解每個專案的成本。因為所有專案的結構都一樣，我可以在任何一個專案裡快速定位問題、快速做修改，不用每次都重新熟悉一套新的組織方式。

這就是累積的力量。AI 可以幫你寫任何 code，但它沒辦法幫你累積這些東西。

### 把自己當成 Code Reviewer、架構師

這是心態上最重要的轉變。

我不把 AI 當成「給我答案的人」，我把它當成「提交 PR 給我 review 的 junior」。它產出的東西，我預設是需要被檢查的。

這不是不信任，而是事實。太多次我直接接受 AI 的 code，後來才發現細節的實作跟我想的不一樣。變數命名有問題、錯誤處理沒考慮周全、edge case 被忽略。

更重要的是，如果我沒有深度參與它實作的細節，這段 code 就不是我的。日後我回頭看，會完全想不起來為什麼這樣寫。或者更糟：我對這個架構的掌握度很差，未來要改的時候，會發現到處都是我不理解的隱患。

Code review 的心態，讓我保持對自己 codebase 的掌控。

### 讓「下指令」變成「思考」

很多人說用 AI 就是下指令，但我認為這個說法太簡化了。

如果你只是說「幫我做一個登入頁面」，AI 會給你一個登入頁面。但這個頁面大概不會符合你的需求，因為你沒有思考過：這個登入頁面要支援哪些登入方式？錯誤訊息要怎麼顯示？Loading 狀態要怎麼處理？跟你現有的 design system 怎麼整合？

當你開始把這些細節想清楚，把指令變得更明確、更精準，你其實就是在思考。

這是我對「AI 時代要怎麼保持思考」的答案：把指令本身變成思考的載體。不是你不用思考了，而是思考的輸出形式變了。從「寫 code」變成「描述 code 該長什麼樣子」。

而這種描述能力，來自於你的實際經驗。就像前面那個 cron job 的例子，AI 不知道不需要輪詢，但我知道。這個「知道」是在場的人才有的優勢。

### 跨出你的舒適圈

這是我最近才意識到的事。

以前我給自己的定位是「Flutter 工程師」。我的工作就是把設計稿變成 App，後端給我 API，我負責串接和呈現。分工明確，各司其職。

但 AI 改變了這個邏輯。

當 AI 可以幫你寫任何語言的 code，「我只會 Flutter」就不再是專業，而是限制。你不需要精通每個領域，但你需要有能力跨進去。

我開始接觸後端。不是要成為後端工程師，而是要理解：這個 API 為什麼這樣設計？這個資料結構合不合理？有沒有更好的方式？當我能跟後端討論這些問題，我就不只是一個「接收規格」的人，而是一個「參與設計」的人。

同樣的道理適用於前端、DevOps、甚至產品設計。你接觸的層面越廣，你能做的判斷就越完整。

AI 降低了跨領域的學習成本。以前要學一門新技術，你得從語法開始慢慢爬。現在你可以直接問 AI：「我想用 Go 寫一個簡單的 API server，幫我快速上手。」它會給你一個能跑的範例，你從範例開始改，邊改邊學。

這是一個前所未有的機會。不要把自己鎖在一個框架裡。

---

## 重新定位：什麼是工程師？

Engineer 這個詞，原本的意思不是「寫程式的人」。

它來自拉丁文 ingenium，意思是「天生的才能、聰明才智」，後來衍伸為「設計或製造精巧裝置的人」。重點是「設計」。在真實的限制條件下，找出解決問題的方法。

一個土木工程師，價值不在於他會搬磚。價值在於他知道這座橋該怎麼設計、用什麼材料、怎麼在預算和工期內完成、怎麼確保它不會塌。

軟體工程師也是一樣。

在 AI 之前，「會寫 code」某種程度上等於「會設計軟體」，因為你不會寫就做不出來。但現在這兩件事被拆開了。AI 會寫，但不會設計。

這意味著，真正的工程師價值，回到了它本來的位置：設計、決策、對現實的判斷。

你要思考的是：

- 這個系統該怎麼切分？
- 哪些東西該抽象、哪些不該？
- 這個技術選型三年後還能維護嗎？
- 這個 feature 真的需要嗎？還是我們在解決一個不存在的問題？

這些問題，AI 沒辦法幫你回答。

---

## 寫在最後

我在 KryptoGO 導入 Clean Architecture 加 Riverpod，建立 monorepo 架構，不是因為這些東西很潮。是因為我們有真實的需求：SDK 要拆出來、白牌服務要支援多個品牌、code 要能被多人同時維護。這些限制條件，決定了架構該長什麼樣。

如果你現在還沒有一套自己熟悉的架構，我認為這是最好的時機去建立。

不是因為有架構比較厲害，而是因為：當你有了藍圖，AI 會讓你的生產力放大十倍。但如果你沒有，你只是在讓 AI 幫你堆一團你自己也看不懂的 code。

那個 code 能跑，但它不是你的。

下次打開 AI 之前，先問自己一個問題：這件事的藍圖，我有嗎？

如果沒有，那就是你該先做的事。

AI 是最好的施工隊。但它永遠不會問你：這棟房子，真的該蓋在這裡嗎？
